(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input:: *)
BeginPackage["PrinLieCalc`PrinLieCalc`",{"MultivariateStatistics`","CUDALink`"}];


$PrePrint=Style[##1,FontSize->16,FontFamily->"Courier"]&;


ad::usage=" ad[A][B] is the adjoint operator or simply, the commutator [A,B] ";


SetOperator::usage= "SetOperator[L_List], sets the list of operators";


UnSetOperator::usage= "UnSetOperator[L_List], unsets the list of operators L to regular elements";


MagnusOperatorList::usage = "Global variable that stores the symbols that are considered Operators";


SetConstantList::usage = "SetConstantsList[L_List], sets the list of constants"


MagnusConstantList::usage = "Global variable that stores the symbols that are considered constants";


SetDipoleList::usage = "SetDipoleList[L_List], sets the dipole list"


MagnusDipoleList::usage = "Global variable that stores the symbols that are used to denote the dipole operators";


FreeOperatorQ::usage= "FreeOperatorQ[expr], oolean function that gives True if expr is free of operators.";


OperatorQ::usage = "OperatorQ[expr], Boolean function that gives True if expr involves an operator.";


DipoleQ::uage = "DipoleQ[w],  Boolean function that gives True if symbol w was defined as dipole operator";


FreeDipoleQ::uage = "FreeDipoleQ[w],  Boolean function that gives True if symbol w was defined as dipole operator";


Commutator::usage = "Commutator[A,B], represents the commutator of A and B and is explicitly evaluated whem A and B are matrices.";


ExpandCommutator::usage="ExpandCommutator[expr] expands a commutator in terms of Dot products"


adToCommutator::usage="AdToCommutator[expr], writes the ad coperators in expr in terms of the respective Commutators ";


d\[CapitalOmega]::usage="d\[CapitalOmega][\[CapitalOmega],n,A], writes the series approximation of \!\(\*FractionBox[\(\[DifferentialD]\), \(\[DifferentialD]t\)]\)\[CapitalOmega](t) of the original differential equation  \!\(\*FractionBox[\(\[DifferentialD]\), \(\[DifferentialD]t\)]\)Y(t) = A Y(y)";


HoldIntegrate::usage="HoldIntegrate[f,{x,x0,xf}], represents the integration of f, but remains unevaluated";


MagnusSeriesRules::usage="MagnusSeries[\[CapitalOmega],t,T,n,A], calculates the rules of the perturbative terms of the frequency operator \[CapitalOmega], up to n order. The integration time uses label t and goes from 0 to T\n
There are three options:\n
1) Method->\"Direct\", which uses drecursive direct integration\n
2) Method->\"RootedTree\", which uses the graphical method of rooted trees \n
3) Mehod-> \"OrderedIntegral\", which expresses the result in terms of orderted integrals instead of nested commutators";


MagnusSeriesList::usage="MagnusSeries[t,T,n,A], calculates the list of the perturbative terms of the frequency operator \[CapitalOmega], up to n order. The integration time uses label t and goes from 0 to T";


MagnusSeries::usage="MagnusSeries[t,T,n,A], calculates the Magnus series on the frequency operator \[CapitalOmega], up to n order. The integration time uses label t and goes from 0 to T";


MagnusPerturbativeTerms::usage = "MagnusPerturbativeTerms[\[CapitalOmega],n,A], generates the truncated differential equation in perturbative terms up to n order";


MagnusOrderedIntegralRules::usage="MagnusOrderedIntegralRules[n,\[CapitalOmega],P], writes the rules of the Magnus expansion in terms of the ordered integrals ";


MagnusOrderedIntegralInvertedRules::usage="MagnusOrderedIntegralRulesInverted[n_?IntegerQ,P_][\[CapitalOmega]_], "


OrderedIntegralRules::usage="OrderedIntegralRules[n,P,t,T,A], gives a list of the first n ordered integrals P[k] with kernel A, time label t and final time T";


EvaluateNumericalField::usage="EvaluateNumericalField[{Field_List,t0},{\[CurlyEpsilon],T,t}][ series ], evaluates the Magnus series numerically on the numerical list Field at time t0. The analytical Magnus series is expanded in terms of analitical field function \[CurlyEpsilon], time variable integration t and top time T "


CCodeGenerationArmadilloList::usage = "CCodeGenerationArmadilloList[{\[CurlyEpsilon]_, F_}, {\[Mu]_, M_}, {f_, g_}][mags_List], generates the c++ code of the List of functions mags."


DotExp::usage="DotExp[n_][X_], expands the exponential of operator X, trunctaed after order n";


DotLog::usage = "DotLog[n_][1+X_], expands the respective log of operator X";


DotSimplify::usage"DotSimplify[expr], simplifies expr involving Dot products"


FullDotSimplify::usage"FullDotSimplify[expr], simplifies expr involving Dot products exhaustively."


ArrangeCommutatorArgLeft::usage="ArrangeCommutatorArgLeft[\[Mu]][expr], arranges the commutators in expr such that operator \[Mu] will try to appear on the left";


BCHExpansionRules::usage="BCHExpansionRules[n_,{A_,B_},Z_], calculates the rules of the Baker\[Dash]Campbell\[Dash]Hausdorff formula series Z[i] that appear in the combination of the product of Exp[A]Exp[B] = Exp[ Z[1] + Z[2] + Z[3]...  ], up to order n\n
There are two available methods:\n
1) Default: Method\[Rule]\"Wilcox\", that uses the Wilcox method\n
2) Method\[Rule]\"Magnus\", that uses a piecewise implementation of the Magnus series 
";


BCHExpansionList::usage="BCHExpansionList[n,{A,B}],  calculates a list of the terms of the Baker\[Dash]Campbell\[Dash]Hausdorff expansion"


WilcoxPolynomial::usage = "WilcoxPolynomial[n, W \[Epsilon]], generates a polynomial in \[Epsilon] with commutator coefficients of the operator W. This polynomial appears when we collect the product of exponentials in a single expeonential such that: \n
Exp[ W[1] \[Epsilon] ] Exp[W[2]\[Epsilon]^2 ] Exp[W[3]\[Epsilon]^3]... = Exp[ WilcoxPolynomial[n, W \[Epsilon]]  ]
";


WilcoxFactorizationRules::usage="WilcoxFactorizationRules[n,{W,\[CapitalOmega]}], Calculates the Wilcox factorization rules up to n order such that  Exp[\[Epsilon] W[1]] Exp[\[Epsilon]^2W[2]] Exp[ \[Epsilon]^3 W[3]]... = Exp[ \[Epsilon] \[CapitalOmega][1] + \[Epsilon]^2 \[CapitalOmega][2] + \[Epsilon]^3 \[CapitalOmega][3]...] ";


WilcoxFactorizationList::usage="WilcoxFactorizationList[n_,\[CapitalOmega]_?OperatorQ], Calculates the Wilcox factorization list \n
{\[Epsilon] W[1], \[Epsilon]^2 W[2], \[Epsilon]^3 W[3]...} up to n order such that  Exp[\[Epsilon] W[1]] Exp[\[Epsilon]^2 W[2]] Exp[\[Epsilon]^3 W[3]]... = xp[ \[Epsilon] \[CapitalOmega][1] + \[Epsilon]^2 \[CapitalOmega][2] + \[Epsilon]^3 \[CapitalOmega][3]...]";


SuperDaggerSimplify::usage="SuperDaggerSimplify[expr], simplifies the operator SuperDagger"


HermitianPart::usage="HermitianPart[X]"


AntiHermitianPart::usage="AntiHermitianPart[X]"


RootedTreeCoefficient::usage="RootedTreeCoefficient[rt], Calculates the coefficient of the rooted tree rt.";


RootedTreeExpression::usage="RootedTreeExpression[n], generates a list of rooted trees of rank n>1";


RootedTreeGraph::usage="RootedTreeGraph[rt], makes the graph of the rooted tree rt.";


RootedTree::usage="RotedTree[i,j], representes a rooted tree, the integer indices are arbitary and are only used for internal organization";


RootedTreeToIntegral::usage="RootedTreeToIntegral[A,t,T][rt], calculates the the Magnus term corresponding to the rooted tree rt. The time variable is t and goes up to T. A is the kernel of the integrals ";


CCodeGeneration::usage="CCodeGeneration[{\[CurlyEpsilon]_,F_},{\[Mu]_,M_},{f_,g_}][mags_], function intended for the C code generation ofr the Magnus expansion. It generates a list of two elements: \n
1) The header functions\n
2) The function definitions\n
Assuming that \[CurlyEpsilon] is the field to be replaced by the array F and \[Mu] is the dipole to be replaced by the array M. \n
f and g are the name of the internal functions needed to make the the C code.\n
The user should define the Commutator in terms of a C++ matrix library.";


CCodeGenerationArmadillo::usage="CCodeGeneration[{\[CurlyEpsilon]_,F_},{\[Mu]_,M_},{f_,g_}][mags_], function intended for the C code generation ofr the Magnus expansion. Generates a list of two elements: \n
1) The header functions\n
2) The function definitions\n
Assuming that \[CurlyEpsilon] is the field to be replaced by the array F and \[Mu] is the dipole to be replaced by the array M in the C++ environment. \n
f and g are the name of the internal functions needed to generate the the C++ code.\n
This function is tailored to use the Armadillo c++ linear algebra package http://arma.sourceforge.net/ ";


CFormStringMatrix::usage = "CFormMatrixString[g_?MatrixQ, x_, G_], writes the C code of a matrix g as a C function G(i-row,j-column, x), where x is the label of the coordinate array x[i]. Obsolete. Now use MatrixCForm "


MatrixCForm::usage=" MatrixCForm[g_?MatrixQ,x,G], writes the C code of a matrix g as a C function G(i-row,j-column, x), where x is the label of the coordinate array x[i]"


ArrayCForm::usage="ArrayCForm[w,var,indxs], writes  the C form of the array w. var is the label of the variable used and inds is a list of indexes to be used in the C code. The length of this list must be equal to the depth of the array. \n For example, a matrix will require two indexes
ArrayCForm[ {{x[1], x[2], x[3]}, {x[4], x[5], x[6]}}, x, {i, j}].
\n The complex number I is converted to the function Complex(0,1)
 "


MakeRealCoefficients::usage="MakeRealCoefficients[w,{x,init,final}], writes the numerical coefficients in w as real floating numbers. It maintains invariant the indexes of the array with label x. It is useful to generate C code."


LieAlgebraCosetB::badinput=" Bad input in LieAlgebraCoset[{n,m},B] ";


LieAlgebraCosetB::usage="deprecited, use CanonicalCosetLieAlgebra instead: LieAlgebraCosetB[{n,m},B], generates the Lie algebra of the coset U(n)/(U(m)U(1)) with label B"


CanonicalCosetLieAlgebra::badinput=" Bad input in CanonicalCosetLieAlgebra[{n,m},B] ";


CanonicalCosetLieAlgebra::usage="CanonicalCosetLieAlgebra[{n,m},B], generates the Lie algebra of the coset U(n)/(U(m)U(1)) with label B"


CosetMatrixX::usage="CosetMatrixX[{n_?IntegerQ,m_?IntegerQ},x], generates the coset matrix with label x of U(n)/(U(m)U(1))\n
Obsolete, use CanonicalCoset instead."


CanonicalCoset::usage = "CanonicalCoset[{n,m},x], generates the coset matrix with label x of U(n)/(U(m)U(1)) "


CanonicalCosetLieAlgebraLayer::usage="CanonicalCosetLieAlgebraLayer[n,m,PM] indicates with 1's the position corresponding to the Lie algebra elements of the coset U(n)/(U(m)U(1)) with permutation matrix PM. The rest of the nxn matrix is filled with 0's";


CanonicalCosetLieAlgebraProjector::usage="CanonicalCosetLieAlgebraProjector[n,m,P] Lie algebra of the coset U(n)/[U(m)U(1)] with  a permutation matrix P";


NextLeftGradientStepFidelityU::usage="NextLeftGradientStepU[W,dt,P][U], delivers the next step in the gradient flow towards W with dt and the possibility of a CanonicalCosetAlgebraProjector function P. The gradient flow looks like the Schrodinger equation."


NextRightGradientStepFidelityU::usage="NextRightGradientStepU[W,dt,P][U], delivers the next step in the gradient flow towards W with dt and the possibility of a CanonicalCosetAlgebraProjector function P"


UToCanonicalCosetCoordinates::usage="UToCanonicalCosetCoordinates[U], extracts the canonical coset coordinates form the numerical unitary operator U after Householder decomposition.\n For illustration, the U(3) decomposition is \n
U=C32.C31.phases
\n
C31=\!\(\*
StyleBox[TagBox[
RowBox[{\"(\", GridBox[{
{\"1\", \"0\", \"0\"},
{\"0\", SqrtBox[
RowBox[{\"1\", \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"1\",\nStripOnInput->False,\nShowContents->False], \"1\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {1}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"2\",\nStripOnInput->False,\nShowContents->False], \"2\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {2}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm]}]], 
RowBox[{
RowBox[{\"-\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"1\",\nStripOnInput->False,\nShowContents->False], \"1\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {1}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}], \"+\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"2\",\nStripOnInput->False,\nShowContents->False], \"2\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {2}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}]},
{\"0\", 
RowBox[{InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"1\",\nStripOnInput->False,\nShowContents->False], \"1\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {1}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \"+\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"2\",\nStripOnInput->False,\nShowContents->False], \"2\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {2}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], 
RowBox[{\"1\", \"+\", FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"1\",\nStripOnInput->False,\nShowContents->False], \"1\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {1}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \"-\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"2\",\nStripOnInput->False,\nShowContents->False], \"2\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {2}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"1\",\nStripOnInput->False,\nShowContents->False], \"1\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {1}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \"+\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"2\",\nStripOnInput->False,\nShowContents->False], \"2\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {2}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{
RowBox[{\"-\", \"1\"}], \"+\", SqrtBox[
RowBox[{\"1\", \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"1\",\nStripOnInput->False,\nShowContents->False], \"1\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {1}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"2\",\nStripOnInput->False,\nShowContents->False], \"2\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {2}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm]}]]}], \")\"}]}], 
RowBox[{TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"1\",\nStripOnInput->False,\nShowContents->False], \"1\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {1}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"+\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"2\",\nStripOnInput->False,\nShowContents->False], \"2\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {2}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm]}]]}]}
},\nGridBoxAlignment->{\"Columns\" -> {{Center}}, \"ColumnsIndexed\" -> {}, \"Rows\" -> {{Baseline}}, \"RowsIndexed\" -> {}, \"Items\" -> {}, \"ItemsIndexed\" -> {}},\nGridBoxSpacings->{\"Columns\" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, \"ColumnsIndexed\" -> {}, \"Rows\" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, \"RowsIndexed\" -> {}, \"Items\" -> {}, \"ItemsIndexed\" -> {}}], \")\"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]],\nStripOnInput->False,\nFontFamily->\"Courier\",\nFontSize->16]\)
\n
C32=\!\(\*
StyleBox[TagBox[
RowBox[{\"(\", GridBox[{
{SqrtBox[
RowBox[{\"1\", \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm]}]], 
RowBox[{
RowBox[{\"-\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}], \"+\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], 
RowBox[{
RowBox[{\"-\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}], \"+\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}]},
{
RowBox[{InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \"+\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], 
RowBox[{\"1\", \"+\", FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \"-\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \"+\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{
RowBox[{\"-\", \"1\"}], \"+\", SqrtBox[
RowBox[{\"1\", \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm]}]]}], \")\"}]}], 
RowBox[{TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"+\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"+\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"+\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm]}]]}], FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \"-\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \"+\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{
RowBox[{\"-\", \"1\"}], \"+\", SqrtBox[
RowBox[{\"1\", \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm]}]]}], \")\"}]}], 
RowBox[{TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"+\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"+\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"+\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm]}]]},
{
RowBox[{InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \"+\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \"+\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \"-\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{
RowBox[{\"-\", \"1\"}], \"+\", SqrtBox[
RowBox[{\"1\", \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm]}]]}], \")\"}]}], 
RowBox[{TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"+\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"+\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"+\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm]}]], 
RowBox[{\"1\", \"+\", FractionBox[
RowBox[{
RowBox[{\"(\", 
RowBox[{InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \"-\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \"+\", 
RowBox[{\"I\", \" \", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False]}]}], \")\"}], \" \", 
RowBox[{\"(\", 
RowBox[{
RowBox[{\"-\", \"1\"}], \"+\", SqrtBox[
RowBox[{\"1\", \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"-\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm]}]]}], \")\"}]}], 
RowBox[{TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"3\",\nStripOnInput->False,\nShowContents->False], \"3\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {3}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"+\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"4\",\nStripOnInput->False,\nShowContents->False], \"4\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {4}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"+\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"5\",\nStripOnInput->False,\nShowContents->False], \"5\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {5}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm], \"+\", TagBox[SuperscriptBox[
RowBox[{\"(\", InterpretationBox[SubsuperscriptBox[\"x\", 
StyleBox[\"6\",\nStripOnInput->False,\nShowContents->False], \"6\"],
TensorCalculus5`Tensorial`Tensor[$CellContext`x, {6}, {TensorCalculus5`Tensorial`Void}],\nBaseStyle->{AutoMultiplicationSymbol -> False},\nEditable->False], \")\"}], \"2\"],
DisplayForm]}]]}]}
},\nGridBoxAlignment->{\"Columns\" -> {{Center}}, \"ColumnsIndexed\" -> {}, \"Rows\" -> {{Baseline}}, \"RowsIndexed\" -> {}, \"Items\" -> {}, \"ItemsIndexed\" -> {}},\nGridBoxSpacings->{\"Columns\" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, \"ColumnsIndexed\" -> {}, \"Rows\" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, \"RowsIndexed\" -> {}, \"Items\" -> {}, \"ItemsIndexed\" -> {}}], \")\"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]],\nStripOnInput->False,\nFontFamily->\"Courier\",\nFontSize->16]\)
phases = DiagonalMatrix[ {Exp[I*x[9]],Exp[I*x[8]],Exp[I*x[7]]}  ]";


CanonicalCosetParametrizationU::usage="CanonicalCosetParametrizationU[n,x,opts], writes the canonical parametrization of U(n). \n 
The default option is
\"Direction\"-> Left, which means that the U(1)^n term is located on the leftmost position. "


CanonicalCosetCoordinatesToU::usage = "CanonicalCosetCoordinatesToU[x0_List], constructs the Unitary matrix from the list of numerical canonical coset coordinates x that represents the canonical coset coordinates with left decomposition."


CanonicalCosetGrapU::usage="CanonicalCosetGrapU[U,opts], graph of unitary operator U"


CanonicalCosetGrapState::usage="CanonicalCosetGrapState[U,\[Psi]0,opts], graph of transition probabilities according with the canonical coset decomposition"


HermitianMatrixIndependentTerms::usage="HermitianMatrixIndependentTerms[M], extracts the independent elements of the hermitian matrix M"


NHaarMetric::usage="NHaarMetric[U], returns the numerical Haar metric  evaluated at the numerical unitary matrix U. The delta used in the numerical computation is 10^(-9)."


NHaarVelocity::usage = "NHaarVelocity[UList,ds], calculates the Haar velocity List from the trajectory of unitary operators UList with  ds as the delta parameter";


NHaarArcLength::usage="NHaarArcLength[UList], calculates the Haar length of the trajectory of unitary matrices UList. The Integration uses the Simpson rule, so it requires the length of UList to be even. "


BuresVolume::usage="BuresVolume[n], calculates the Bures volume in n dimensions"


CanonicalCosetDecomposition::usage="CanonicalCosetDecomposition[W,PM,opts], it decomposes the numerical matrix W in terms of the canonical coset decomposition, using the Householder method. The decomposition is not unique, and alterntive decompositions can be found with alternative permutation matrices PM.\n
The default option is \"Direction\"\[Rule]Left, which means that the U(1)^N diagonal matrix factor is located on the rightmost place. The alternative direction is Right.
 "


CanonicalCosetLeftDecompositionGradient::usage="\[IndentingNewLine]CanonicalCosetLeftDecompositionGradient[W ,PM ,{ds,error}], performs the Left Canonical Coset Decomposition in the sense that the U(1)^N  factor is located on the right and the other cosets. The gradient flow looks like the Schrodinger equation.   "


CanonicalCosetRightDecompositionGradient::usage="\[IndentingNewLine]CanonicalCosetRightDecompositionGradient[W ,PM ,{ds,error}], performs the Left Canonical Coset Decomposition in the sense that the U(1)^N factor is located on the left and the other cosets \n Example 
CanonicalCosetRightDecompositionGradient[ W, PermutationMatrix[{1, 2, 3}], {0.1, 10^(-12)}]  "


HouseholderDecomposition::usage="HouseholderDecomposition[W,sign,opts], Performs th Householder decomposition of matrix W. \n The default sign is sign=1 and the default option opts is \"Direction\"->Left \n The alternative option is Right "


HouseholderLeftDecomposition::usage = "HouseholderLeftDecomposition[W,sign], Performs the Householder decomposition of a matrix W. sign may be 1 or -1. This is the standard form of the Householder decomposition. Depreciated, use HouseholderDecomposition instead"


HouseholderRightDecomposition::usage = "HouseholderDecomposition[W,sign], Performs the Householder decomposition of a matrix W. sign may be 1 or -1. Depreciated, use HouseholderDecomposition instead."


CanonicalCosetBallCoordinates::usage="CanonicalCosetBallCoordinates[U], obtains the ball coordinates that parametrize the canonical cosets in default mode with pemutation matrix equal to the identity"


BlockCanonicalCosetDecomposition::usage="BlockCanonicalCosetDecomposition[U,opts], decomposes the matrix U of dimension 2^n into two canonical cosets. The default option is Directon->left, which places the block diagonal elements on the right side. The other default option is Subgroup->2 in order to stop the recursion at U(2) blocks. The diagonal subgroup is obtained with Subgroup->1  ";


KAKCanonicalCosetDecomposition::usage="KAKCanonicalCosetDecomposition[U,nIterations_,T], performs the Cartan KAK matrix decomposition according with the block canonical coet decomposition. This decomposition depends on the pivot unitary matrix. nIterations is the number of recursions to perform"


FactorizeRightQubits::usage="FactorizeLeftQubits[B_] , Given that B is made of two block matrices 2^n with equal size, it factorizes B into two matrices where the right factor is decoupled with the left qubit"


GeneralizedCanonicalCosetDecomposition::usage="GeneralizedCanonicalCosetDecomposition[U,opts], Depreciated, use   BlockCanonicalCosetDecomposition";


GeneralizedCanonicalCosetDecompositionLeft::usage="GeneralizedCanonicalCosetDecompositionLeft[U], Depreciated, decomposes U into two matrices, the right one being block diagonal"


QubitExtractionU8Left::usage="QubitExtractionU8Left[U,n], Depreciated, decomposes U(8) in two factors, the right one being the single nth qubit ";


SingleQubitExtractionU8::usage="SingleQubitExtractionU8[U,iteration],Depreciated, decomposes U(8) in a sequence of unitary matrices such that the second, third and fourth terms in the list are single qubit expressions. iteration is the number of iterations in the algorithm. ";


QubitExtractionU4Left::usage="QubitExtractionU4Left[U,n], Depreciated decomposes U(4) in two factors, the right one being the single nth qubit ";


SingleQubitExtractionU4::usage="SingleQubitExtractionU4[U,iteration], Depreciated decomposes U(4) in a sequence of unitary matrices such that the second, third and fourth terms in the list are single qubit expressions. iteration is the number of iterations in the algorithm. The option \"Direction\" is set to Left by deafult. ";


SurroundingNeighborhood::usage="SurroundingNeighborhood[n], gives a set of neighboorhood vector points in a n-dimensional grid around the zero vector point.";


MCommutator::usage="MCommutator[A,B] calculates the commutator of matrices A and B";


MAntiCommutator::usage="MAntiCommutator[A,B] calculates the anti-commutator of matrices A and B";


SelectDiagonalMatrices::usage="SelectDiagonalMatrices[M_List] selects all the diagonal matrices in list of matrices M";


MatrixLeftProjector::usage="MatrixLeftProjector[n], generates the leftmost n x n matrix projector ";


SelectDiagonalMatrices::usage"SelectDiagonalMatrices[M], selects the diagonal matrices of the list of matrices M.";


MHermitianConjugation::usage="MHermitianConjugation[M] Calculates the Hermitian conjugation of matrix M";


RightPartialTr::usage="RightPartialTr[M] calculates the right qubit partial trace of the n-qubit matrix M (dimension 2^)";


LeftPartialTr::usage="LeftPartialTr[M] calculates the left qubit partial trace of the n-qubit matrix M (dimension 2^)";


ExtractHermitianMatrixComponents::usage="ExtractHermitianMatrixComponents[M], extracts the independents terms of the Hermitian matrix M.";


MatrixCos::usage="MatrixCos[M] Calculates the matrix cos of M";


MatrixSin::usage="MatrixSin[M] Calculates the matrix sin of M";


MForceHermitianConjugation::usage = "MForceHermitianConjugation[ M ], forces the Hermitian conjugation of matrix M, such that all symbols are considered real by default."


LinearlyIndependentMatricesQ::usage="LinearlyIndependentMatricesQ[M], Tells if the list of matrices M is linearly independent"


CompleteLieAlgebra::usage = "CompleteLieAlgebra[{M1,M2,M3...},opt], Calculates a whole set of basis of the Lie algebra from the initial seto of generators M1, M2, M3,... opt=CompleteLieAlgebra->True to show indexes"


IndexedLieAlgebra::usage="Option of CompleteLieAlgebra";


PauliMatrixToParavector::usage = "PauliMatrixToParavector[M], writes the 2x2 complex matrix M into a list of four complex numbers that represent the paravector components";


PauliMatrixToVector::usage = "PauliMatrixToVector[M], writes the 2x2 complex matrix M into a list of Tree complex numbers that represent the vector components. This transformation loses information about the scalar part.";


VectorToPauliMatrix::usage=" VectorToPauliMatrix[x], writes the 3D vector x as a 2x2 complex matrix ";


ParavectorToPauliMatrix::usage="ParavectorToPauliMatrix[x], writes the 4 component paravector as a 2x2 complex matrix";


MForceHermitianConjugation::usage = "MForceHermitianConjugation[x] forces the Hermitean conjuagtion assuming all symbols are real by dafult";


RandomUnitaryMatrix::usage = "RandomUnitaryMatrix[N] generates a random N x N unitary matrix";


RandomOrthogonalMatrix::usage="RandomOrthogonalMatrix[N], generates a random NxN orthogonal matrix";


RandomSeparableNQubitUnitaryMatrix::usage = "RandomSeparableNQubitUnitaryMatrix[n], generates a random separable n-qubit unitary matrix";


RandomSUnitaryMatrix::usage="RandomSUnitaryMatrix[n] generates a random special unitary matrix";


EntropyS::usage="EntropyS[L], Entropy as a function of the eigenvalues spectrum"


MetropolisSampling::usage = "MetropolisSampling[f,xinit,dx,n]"


GibbsSampling::usage = "GibbsSampling[f,xinit,dx,n]"


RandomSpherePoint::usage = "RandomSpherePoint[dim], Generates a random point in a sphere of dimension dim"


RandomBallPoint::usage = "RandomBallPoint[dim], generates a random point in a ball of dimension dim"


MHermitianPart::usage = "MHermitianPart[x], Hermitian part"


MAntiHermitianPart::usage="MAntiHermitianPart[x], AntiHermitian part"


TracelessPart::usage="TracelessPart[nDim][x], traceless part in dimension nDim"


LocalDiagonalizerU::usage="LocalDiagonalizerU[SepState], finds the n-qubit factorizable unitary operator from a pure separable state.  ";


MPrimitiveProjector::usage = "MPrimitiveProjector[n][j] The primitive projector for a n-level system, with the j-diagonal element 1."


MQubitPrimitiveProjector::usage = "MQubitPrimitiveProjector[signs_List] The primitive projector matrix for n-qubits with n=Length[signs]  "


suNQLieALgebra::usage = "suNQLieALgebra[nQ]"


USpBasis::usage="USpBasis[n] , writes a set of symmetric antihermitian matrices that ultimatelly generate usp[n] (Unitary symplectic)";



SeparableNQLieALgebra::usage="SeparableNQLieALgebra[n], separable Lie algebra basis of for n-qubits"


LocalComponent::usage="LocalComponent[n][ M ] projects su(2^n) on su(2)^n . M  as a traceless matrix"


ChevalleyMatrix::usage="ChevalleyMatrix[N,{j,k}], it gives the Chevalley NxN matrix."


ChevalleyOffDiagonalBasis::usage="ChevalleyOffDiagonalBasis[N], it gives the NxN Chevalley off diagonal basis."


CartanDecompositionQ::usage="CartanDecompositionQ[t_List,p_List], 
  For a partition of the complete Lie algebra into t and p such that this basis is orthogonal respect to the trace, this function gives a list of 3 boolean variables. 
  \n 1: the commutators among t are outside p (t must be a subLie algebra) 
  \n 2: the commutators between p and t are outside t  
  \n 3: the commutators among p are outside p.";


RightPartialTranspose2Q::usage = "RightPartialTranspose2Q[M] "


NegativityEntanglement2Q::usage = "NegativityEntanglement2Q[m]"


ForceRe::usage="ForceRe[x], calculates the real part assuming all symbols are real"


ForceIm::usage="ForceIm[x], calculates the real part assuming all symbols are real"


GellMannSUNGenerators::usage="GelmannSUNGenerators[N], obsolete, use GellMannMatrices instead"


GellMannMatrices::usage = "GelmannMatrices[N], generates the N^2-1 GellMann matrices"


GellMannProjection::usage="GellMannProjection[ind_List][M_?MatrixQ], Projects the matrix M in the space spanned by the GellMan matrices with indices ind. The indices come from 0 to N^2-1, with 0 standing for the trace part."


DaggerUdUd\[Phi]::usage="DaggerdUd\[Phi][\[Phi],d\[Phi],\[Phi]Range,\[Lambda]Sequence,n][k], calculates the differential of the k \[Phi]-angle that lies in the \[Phi]Range. \[Lambda]Sequence is the sequnce of indices of the generators that parametrize the range. The result belongs to the Lie algebra of SU[n] group";

dUd\[Phi]::usage="dUd\[Phi][\[Phi],d\[Phi],\[Phi]Range,\[Lambda]Sequence,n][k], Obsolete, use DaggerUdUd\[Phi] instead";


DaggerUdU::uage="DaggerUdU[\[Phi]_,d\[Phi]_,\[Phi]Range_,\[Lambda]Sequence_,n_], calculates the total differential of the Unitary matrix manifold of the angles in the range\n
The parametrization in term sof nxn matrices is :\n
U = ...Exp[\!\(\*SubscriptBox[\(\[Lambda]\), \(3\)]\)]Exp[\!\(\*SubscriptBox[\(\[Lambda]\), \(2\)]\)].Exp[\!\(\*SubscriptBox[\(\[Lambda]\), \(1\)]\)], where \!\(\*SubscriptBox[\(\[Lambda]\), \(1\)]\) is the first element of \[Lambda]Sequence
";


dU::uage="dU[\[Phi]_,d\[Phi]_,\[Phi]Range_,\[Lambda]Sequence_,n_], obsolete, use DaggerUdU instead";


dVolumeU::usage="dVolume[\[Phi],d\[Phi],\[Phi]Range,\[Lambda]Sequence,n], calculates the volume of a manifold embedded in a nxn unitary matrix  parametrized with Euler angles \[Phi]. \[Lambda]Sequence is the chosen sequence of Euler generators.";


IgnoreSignUnion::usage="IgnoreSignUnion[w], Union considering two elements with different sign equal"


MultipleTaylorExpansion::usage="MultipleTaylorExpansion[f_,{x_,dx_,n_}], "


QuadraticCoefficientArrays::usage="QuadraticCoefficientArrays[variables][ quadraticExpression], Obtains the symmetric matrix from the quadratic form."


SphereVolume::usage = "SphereVolume[n], the volume of the n-sphere "


BallVolume::usage="BallVolume[n], the volume of the n-ball"


HypersphericalCoordinates::usage="HypersphericalCoordinates[n_,\[Theta]_]"


PermutationMatrix::usge="PermutationMatrix[perm_List], is a square permuation matrix. This matrix is made by reordering the rows of the identity matrix according to the list perm, which is a permutation of integers from 1 to n."


PermutationToInversionTable::usage="PermutationToInversionTable[perm_List], transforms the permutation of integers perm into its one to one inversion table vector space."


InversionTableToPermutation::usage="InversionTableToPermutation[v_List] transforms the inversion table v into its one to one permutation"


ContingencyTables::usage = "ContingencyTables[stateEigenvalues,observableEigenvalues]"


HessianAxis::usage = "HessianAxis[contingencyTable]"


MultinomialPartitions::usage="MultinomialPartitions[n, k], 
Generates a list of the possible integer partition of integer k into n subsets with possible repetion and empty subsets.\n
 The number of possible combinations is equal to the dimension of the symmetric tensor of order k with indexes runing from 1 to n: Binomial[n + k - 1, k]. These partitions can represent the powers of n variables of a multinomial term with degree k."


MultinomialPartitionToSymmetricArray::usage="MultinomialPartitionToSymmetricArray[pows,T], gives one of the possible permutations of the symmetric arrays representation of the multinomail partition pows. Each array index indicates the precence of the respective variable from 1 to n.\n 
MultinomialPartitionToSymmetricArray[{3, 1, 0, 0, 0, 0}, T] => T[2,1,1,1] , because the variable 1 appears three times and the variable 2 appears once. 
";


SymmetricArrayValueRules::usage="SymmetricArrayValueRules[T_,{n_,k_},vals_], generates a list of rules for the values in the flat List vals for the symmetric array T with index range 1 to n and tensor order k. The convention of the indexes is given by the function MultinomialPartitions";


SymmetricArrayPartition::usage="SymmetricArrayPartition[{n,k},list], partitions list into a symmetric k-dimensional tensor represented as a multidimensional-array with indexes in the range 1 to n. The Length of list must be equal to the number of independent elements of the respective symmetric tensor:\n Binomial[n + k - 1, k]. The convention of the indexes is given by the function MultinomialPartitions";


SymmetricArrayElementToPolynomial::usage="SymmetricArrayElementToPolynomial[ S , x ], writes the assumed symmetric array element S as a polinomial term.  "


SymmetricArrayToHomogeneousPolynomial::uage="SymmetricArrayToHomogeneousPolynomial[A, x], writes the symmetric array A as a homogeneous polynomial with label x"


SymmetricArrayCoefficientsToHomogeneousPolynomial::usage = "SymmetricArrayCoefficientsToHomogeneousPolynomial[L_List,{n,k},x], generates the homogeneous polynomial with label variables x from the list of independent coefficients L of a k-dimensional symmetric array with range index 1 to n"


GivensRotation::usage="GivensRotation[n,{i,j},c], generates a n x n Givens rotation matrix for the {i,j} indexes. The cosine value of the Givens rotation is c."


GaussianIntegral::usage="GaussianIntegral[M_] , calulates the gaussian integral of the xponential with covariance M"


GaussianSecondMoment::usage="GaussianSecondMoment[M_,p_,q_], calculates the second order moment of the Gaussian distributions for the covariance matrix M"


TranslationOperatorT::usage="TranslationOperatorT[d], the translation operator for dimension d"


MomentumOperatorP::usage="MomentumOperatorP[{d,n},a], the discrete momentum  operator for a spatial discretization number d with geometric dimensionality n and spatial resolution a"


ToComplexExpExpression::usage="ToComplexExpExpression[expr], writes -1 as Exp[I*Pi]"


BoostOperatorB::usage="BoostOperatorB[d], the momentum boos operator in d dimensions"


PositionOperatorX::usage="PositionOperatorX[{d,n},a], the discrete position operator with space resolution a, spatial discretization d and geometric dimensionality n"


EhrenfestFreeHamiltonian::usage="EhrenfestFreeHamiltonian[{d_?IntegerQ,n},a_], the Ehrenfest free Hamiltonian with space resolution a for n particles, each in d dimensions."


DiagonalKineticEnergyPSquare::usage="DiagonalKineticEnergyPSquare[{d,n},a,m], discrete P^2/2m for dimension d, spatial resolution a, n particles. The diagonalization is done by the Fourier matrix"


PropagatorStep1D::usage="PropagatorStep1D[{V_,m_,dx_,dt_},\[Psi]_], discrete Potential V, mass m, dx, dt and wave function \[Psi]"


BlockDiagonalizerMatrix::usage = "BlockDiagonalizerMatrix[d,n], diagonalizer for a block diagonal system in n dimensions with grid size d"


KroneckerSum::usage="KroneckerSum[{M1,M2,M3..}], performs the Kronecker sum of the list of matrices M1,M2,.. which should have the same dimension."


SymmetricWignerFunction::usage="SymmetricWignerFunction[g], Calculates the discrete wigner function of complex vector g in the position space. The dimension of g can be even or odd and is labeled by indices j = -J,..+J, where J = (n-1)/2 and n is the dimension of g. The output W is constructed such that Plus@@W is the probability distribution in the position space and Plus@@Transpose[W] is the probability distribution in the momentum space. The momentum space is defined as the symmetric discrete Fourier transform of the position space. This function does not use the fast Fourier transform. Therefore, it is not numerically efficient"


WignerFunctionFFT::usage="WignerFunctionFFT[g], Calculates the Wigner function (2D) of the one-dimensional vector g. This function utilizes the fast Fourier Transform."


SymmetricFourier::usage="SymmetricFourier[v], performs the Fourier transform with symmetric indices (positive exponent)"


FastSymmetricFourier::usage = "FastSymmetricFourier[v], performs the symmetric discrete Fourier transform by double shifting"


FastSymmetricInverseFourier::usage = "FastSymmetricInverseFourier[v], performs the symmetric discrete inverse Fourier transform by double shifting"


SymmetricInverseFourier::usage="SymmetricInverseFourier[v], performs the inverse Fourier transform with symmetric indices (negative exponent)"


SymmetricFourierMatrix::usage="SymmetricFourierMatrix[{n,1}], the symmetric Fourier matrix in 2^n dimensions for a single particle. \n
SymmetricFourierMatrix[{n,1}] for two particles"


SymmetricInverseFourierMatrix::usage="SymmetricInverseFourierMatrix[{n,1}], the symmetric Fourier matrix in 2^n dimensions for a single particle. \n
SymmetricInverseFourierMatrix[{n,2}] for two particles"


StandardFourierMatrix::usage="StandardFourierMatrix[n], the standard Fourier matrix in 2^d dimensions"


SymmetricFFT::usage="SymmetricFFT[X_?VectorQ], Performs the index-symmetric fft with the dimension of X as power of 2 (Positive exponential)";


SymmetricInverseFFT::usage="SymmetricInverseFFT[X_?VectorQ], Performs the index-symmetric inverse fft with the dimension of X as power of 2 (negative exponential)";


SymmetricFourier2D::usage="SymmetricFourier2D[matrix], the symmetric-index 2D Fourier Transform.\n
 SymmetricFourier2D[vector] partitions vector in a matrix and proceeds with the 2D Fourier transform."


SymmetricInverseFourier2D::usage="SymmetricInverseFourier2D[w_?MatrixQ] the inverse symmetric-index 2D Fourier Transform.\n
 SymmetricInverseFourier2D[vector] partitions vector in a matrix and proceeds with the 2D inverse Fourier transform."


LeftSymmetricFourier2D::usage="LeftSymmetricFourier2D[v], the symmetric Fourier transformation on the left side of the two-slot Kronecker product"


LeftSymmetricInverseFourier2D::usage="LeftSymmetricInverseFourier2D[v], the symmetric Fourier transformation on the left side of the two-slot Kronecker product"


SymmetricFFTPartial10::usage="SymmetricFFTPartial10[X_?VectorQ], partial Fourier transform left particle"


SymmetricInverseFFTPartial10::usage="SymmetricInverseFFTPartial10[X_?VectorQ], partial inversere symmetric-indexed Fourier transform, left particle"


SymmetricFFTPartial01::usage="SymmetricFFTPartial01[X_?VectorQ], partial symmetric-indexed Fourier transform, right particle"


SymmetricInverseFFTPartial01::usage="SymmetricInverseFFTPartial01[X_?VectorQ], partial inversere symmetric-indexed Fourier transform, right particle"


SymmetricFFTPartial100::usage = "SymmetricFFTPartial100[X], partial symmetric-indexed Fourier transform"


SymmetricInverseFFTPartial100::usage = "SymmetricInverseFFTPartial100[X_], partial symmetric-indexed inverse Fourier transform"


SymmetricFFTPartial001::usage = "SymmetricFFTPartial001[X], "


SymmetricFFTPartial010::usage="SymmetricFFTPartial010[X], partial symmetric-indexed Fourier transform"


FourierColumns::usage = "Fourier transform in columns"


FourierRows::uage = "Fourier Transform in rows"


ShiftFrequencyRows::usage = "ShiftFrequency in Rows"


ShiftFrequencyColumns::usage = "Shift Frequency in columns"


InverseFourierColumns::usage = "Inverse FOurier columnns"


InverseFourierRows::usage = "Inverse Fourier rows"


SetUnifiedPropagationFrame1D::usage="SetUnifiedPropagationFrame[{K,V,Initial\[Psi]},{discretizationNumber,nTimeFrames},{\[CapitalDelta]x,\[CapitalDelta]p,T}], gives a list of three elements: \n
{ExpKShiftColumns,ExpVShiftRows,\[Psi]0}\n
ExpKShiftColumns is the complex exponetial of the unified kinetic energy grid, provided by the function K[\[Lambda],p] \n
ExpVShiftRows is the complex exponential of the unified potential energy grid, provided by the function V[x,\[Theta]] \n
\[Psi]0 is the initial gaussian wavefunction grid, provided by the function Initial\[Psi] \n
 discretizationNumber is the spatial grid discretization number as power of 2 \n
nTimeFrames is the number of frames  for the propagation\n
\[CapitalDelta]x,\[CapitalDelta]p are the range of the grid in the x-p representation\n
T is the maximum time propagation from zero
"


StepPropagationXP::usage="StepPropagationXP[ExpKShiftColumns,ExpVShiftRows][\[Psi]], generates a new frame of the propagation of \[Psi], in the x-p representation based on the grids for the exponentials of the inetic energy and potential energy generated by the function SetUnifiedPropagationFrame1D"


SymplecticPropagator2::usage = "SymplecticPropagator2[X,dTdp,dVdq,t0,T,DIMtime], propagates the phase-space vector X from time t0 to T with DIMtimes steps.\n
dTdp[q,p] and dVdq[q,p] are the derivatives of the kinetic energy and potential energy, respect to the momentum and position.
"


(* ::Input:: *)
Begin["`Private`"];


MakeBoxes[ad[A_][B_],form:StandardForm|TraditionalForm]:= 
InterpretationBox[#1,#2,Editable->False]&@@{RowBox[{SubscriptBox[MakeBoxes["ad",form],MakeBoxes[A,form]],MakeBoxes[B,form]}],ad[A][B]}


MakeBoxes[ad[A_,n_][B_],form:StandardForm|TraditionalForm]:= 
InterpretationBox[#1,#2,Editable->False]&@@{ RowBox[{SubsuperscriptBox[MakeBoxes["ad",form],MakeBoxes[A,form],MakeBoxes[n,form]],MakeBoxes[B,form]}] ,ad[A,n][B]}


MakeBoxes[Commutator[A_,B_],form:StandardForm|TraditionalForm]:= 
InterpretationBox[#1,#2,Editable->False]&@@{RowBox[{MakeBoxes["[",form],MakeBoxes[A,form],MakeBoxes[",",form],MakeBoxes[B,form],MakeBoxes["]",form]}],Commutator[A,B]}


MakeBoxes[HoldIntegrate[A_,{x_,x0_,xf_}],form:StandardForm|TraditionalForm]:=InterpretationBox[#1,#2,Editable->False]&@@{ 
 RowBox[{ UnderoverscriptBox["\[Integral]",MakeBoxes[x0,form],MakeBoxes[xf,form]] ,MakeBoxes[A,form],MakeBoxes["\[DifferentialD]",form],MakeBoxes[x,form]}]
,HoldIntegrate[A,{x,x0,xf}]}


SetOperator[L_List]:= Module[{temp},
If[ AtomQ@MagnusOperatorList,
MagnusOperatorList:= L
,temp=MagnusOperatorList;
ClearAll[MagnusOperatorList];
MagnusOperatorList:= Union@Join[temp,L]
]
]


UnSetOperator[L_List]:=Module[{},MagnusOperatorList=Complement[MagnusOperatorList,Intersection[MagnusOperatorList,L]];]


SetConstantList[L_List]:= Module[{temp},
If[ AtomQ@MagnusConstantList,
MagnusConstantList:= L
,temp=MagnusConstantList;
ClearAll[MagnusConstantList];
MagnusConstantList:= Union@Join[temp,L]
]
]


SetDipoleList[L_List]:= Module[{temp},
If[ AtomQ@MagnusDipoleList,
MagnusDipoleList:= L
,temp=MagnusDipoleList;
ClearAll[MagnusDipoleList];
MagnusDipoleList:= Union@Join[temp,L]
]
]


WilcoxFactorizationList[n_,\[CapitalOmega]_?OperatorQ]:=Module[{Y,return,x,y},SetOperator[{Y}];
return=WilcoxFactorizationRules[n,{Y,\[CapitalOmega]}]/.Rule[x_,y_]->y;
UnSetOperator[{Y}];
return]


OperatorQ[w_]:=Module[{},
Flatten[Position[{w},#,{0,Infinity},1]&/@MagnusOperatorList]=!={}
]


FreeOperatorQ[w_]:=Module[{},
Flatten[Position[{w},#,{0,Infinity},1]&/@MagnusOperatorList]==={}
]


ad[A_][A_]:=0


ad[_][x_?NumericQ]:=0
ad[_][x_?FreeOperatorQ]:=0


ad[x_?NumericQ][_]:=0
ad[x_?FreeOperatorQ][_]:=0


ad[a_?NumericQ*A_][B_]:=a*ad[A][B]
ad[A_][a_?NumericQ*B_]:=a*ad[A][B]


ad[a_?FreeOperatorQ*A_][B_]:=a*ad[A][B]
ad[A_][a_?FreeOperatorQ*B_]:=a*ad[A][B]


ad[A_+B_][C_]:=ad[A][C]+ad[B][C]
ad[A_][B_+C_]:=ad[A][B]+ad[A][C]


Protect[epsi];


ad[epsi^n_*A_][B_]:=epsi^n*ad[A][B]
ad[A_][epsi^n_*B_]:=epsi^n*ad[A][B]


ad[A_,n_][B_]:=ad[A][ad[A,n-1][B]];
ad[A_,0][B_]:=B;


adToCommutator[expr_]:=Module[{a,b},
 expr//.HoldPattern[ad[a_][b_]]:>  Commutator[a,b]
]


Commutator[A_?MatrixQ,B_?MatrixQ]=A.B-B.A


Commutator[A_,A_]:=0


Commutator[_,x_?NumericQ]:=0
Commutator[_,x_?FreeOperatorQ]:=0


Commutator[x_?NumericQ,_]:=0
Commutator[x_?FreeOperatorQ,_]:=0


Commutator[a_?NumericQ*A_,B_]:=a*Commutator[A,B]
Commutator[A_,a_?NumericQ*B_]:=a*Commutator[A,B]


Commutator[a_?FreeOperatorQ*A_,B_]:=a*Commutator[A,B]
Commutator[A_,a_?FreeOperatorQ*B_]:=a*Commutator[A,B]


Commutator[A_+B_,C_]:=Commutator[A,C]+Commutator[B,C]
Commutator[A_,B_+C_]:=Commutator[A,B]+Commutator[A,C]


ArrangeCommutatorArgLeft[\[Mu]_][w_]:=Module[{X,Y,step,rule1,rule2},
rule1={HoldPattern[Commutator[X_,\[Mu]]]:>-Commutator[\[Mu],X]};
rule2={HoldPattern[Commutator[X_?(Position[{#},\[Mu]]==={}&),Y_]]:>-Commutator[Y,X]};
Collect[ Expand[w//.Join[rule1,rule2]],{HoldPattern[Commutator[__]]}]
]


ExpandCommutator[expr_]:= Module[{A,B},
expr//.HoldPattern[Commutator[A_,B_]]:> A.B-B.A
]


DotExp[n_][X_]:=Module[{},1+NestList[FullDotSimplify[X.#]&,X,n-1].Table[1/k!,{k,1,n}]];


DotLog[n_][1+X_]:=Module[{count=1},NestList[FullDotSimplify[X.#]&,X,n].Prepend[Table[(-1)^k/(k+1),{k,1,n}],1]]


DotSimplify[expr_] := Module[
  {rule1, rule2, rule3, rule4, rule5, a, X, Y, step}, rule1 = {Dot[X__?OperatorQ, a_?FreeOperatorQ, Y___] :> Dot[a, X, Y]};
    rule2 = {Dot[a_?FreeOperatorQ, X__?OperatorQ] :>  a*Dot[X]};
    rule3 = {HoldPattern[Dot[a__?FreeOperatorQ]] :>  Times[a]};
    rule4 = {Dot[X_?(Length[{#}] == 1 &)] :>  X};
    step = (Map[Distribute[#, Dot, Dot] &, expr, 2] /. Times -> Dot);
    ((((step //. rule1) //. rule2) //. rule3) //. rule4)
  ]


FullDotSimplify[expr_] := Module[{X, a, b, rule}, rule = {Dot[X_, a_ + b_] -> Dot[X, a] + Dot[X, b], Dot[a_ + b_, X_] -> Dot[a, X] + Dot[b, X]};
    FixedPoint[DotSimplify[# //. rule] &, expr]]


SuperDaggerSimplify[expr_]:=Module[{P,Q,rule0,rule1,rule2,rule3,a,b},rule0={SuperDagger[P_?FreeOperatorQ]:>Conjugate[P]};
rule1={SuperDagger[a_Plus]:>SuperDagger/@a};
rule2={SuperDagger[a_?FreeOperatorQ*b_]:>Conjugate[a]*SuperDagger[b]};
rule3={SuperDagger[Dot[P__,Q_]]:>Dot[SuperDagger@Q,SuperDagger@P]};
(expr//.Join[rule0,rule1,rule2])//.rule3]


HermitianPart[0]:=0


AntiHermitianPart[0]:=0


HermitianPart[Equal[X_,Y_]]:=Equal[HermitianPart[X],HermitianPart[Y]]


AntiHermitianPart[Equal[X_,Y_]]:=Equal[AntiHermitianPart[X],AntiHermitianPart[Y]]


HermitianPart[X_]:= SuperDaggerSimplify[(X+SuperDagger[X])]/2


AntiHermitianPart[X_]:= SuperDaggerSimplify[(X-SuperDagger[X])]/2


HoldIntegrate[0,x_]:=0;


HoldIntegrate[a_?NumericQ*f_,x__]:=a*HoldIntegrate[f,x]


HoldIntegrate[a_*f_,{x_,x0_,x1_}]/;(Flatten[Position[{a},x]]==={}):=a*HoldIntegrate[f,{x,x0,x1}]


HoldIntegrate[a_,{x_,x0_,x1_}]/;(Flatten[Position[{a},x]]==={}):=a*(x1-x0)


HoldIntegrate[f_+g_,x__]:=HoldIntegrate[f,x]+HoldIntegrate[g,x]


HoldIntegrate[a_*(f_+g_),x__]:=HoldIntegrate[a*f,x]+HoldIntegrate[a*g,x]


d\[CapitalOmega][\[CapitalOmega]_,n_,A_]:=Sum[1/k!*BernoulliB[k]*ad[\[CapitalOmega],k][A],{k,0,n}]


MagnusPerturbativeTerms[\[CapitalOmega]_,n_?IntegerQ,A_]:=Module[{eps,k},Flatten@Take[Normal@CoefficientArrays[Expand[adToCommutator[d\[CapitalOmega][Sum[eps^k*\[CapitalOmega][k],{k,1,n}],n,A]]],{eps}],n+1]]


Options[MagnusSeriesRules]={Method->"DirectIntegration"};


MagnusSeriesRules[\[CapitalOmega]_,t_,T_,n_?IntegerQ,A_?OperatorQ,opts:OptionsPattern[]]:=Module[{},
Which[
OptionValue[Method]==="DirectIntegration",MagnusSeriesRulesDirect[\[CapitalOmega],t,T,n,A],
OptionValue[Method]==="RootedTree", MagnusSeriesRulesRootedTree[\[CapitalOmega],t,T,n,A],
OptionValue[Method]==="OrderedIntegral", MagnusSeriesRulesOrderedIntegral[\[CapitalOmega],t,T,n,A]
]
]


MagnusSeriesRulesOrderedIntegral[\[CapitalOmega]_,t_,T_,n_,A_]:=Module[{P,return},
SetOperator[{P}];
return=MagnusOrderedIntegralRules[n,\[CapitalOmega],P]/.OrderedIntegralRules[n,P,t,T,A];
UnSetOperator[{P}];
return
]


MagnusSeriesRulesRootedTree[\[CapitalOmega]_,t_,T_,n_?IntegerQ,A_?OperatorQ]:=Module[{k,first,rest},
first =  \[CapitalOmega][1]->HoldIntegrate[  A@t[1] , {t[1],0,T} ];
rest=Table[
\[CapitalOmega][k]->  Plus@@(RootedTreeToIntegral[A,t,T]/@RootedTreeExpression[k])
,{k,2,n}];
Prepend[rest,first]
]


MagnusSeriesRulesDirect[\[CapitalOmega]_,t_,T_,n_?IntegerQ,A_?OperatorQ]:=Module[{expan,initRules,texpan,k,m,p,x,step},
expan=MagnusPerturbativeTerms[\[CapitalOmega],n-1,A];
texpan=MapThread[#1/.{A->A[#2],\[CapitalOmega][m_]->\[CapitalOmega][m][#2]}&,{expan,Array[t,n]}];
initRules={\[CapitalOmega][1][Pattern[p,_]]->HoldIntegrate[First@texpan,{t[1],0,p}]};
m=2;
step=Fold[Append[#1,\[CapitalOmega][m++][p_]->HoldIntegrate[(#2/.#1),{t[m-1],0,p}]]&,initRules,Rest@texpan];
step/.{ToExpression["PrinLieCalc`PrinLieCalc`Private`p$"]->T,\[CapitalOmega][x_][_]-> \[CapitalOmega][x]}]


Options[MagnusSeriesList]={Method->"DirectIntegration"};


MagnusSeriesList[t_,T_,n_?IntegerQ,A_?OperatorQ,opts:OptionsPattern[]]:=Module[{x,y,return,Omega},SetOperator[{Omega}];
return=MagnusSeriesRules[Omega,t,T,n,A,opts]/.Rule[x_,y_]->y;
UnSetOperator[{Omega}];
return]


MagnusSeries[t_,T_,n_?IntegerQ,A_?OperatorQ,opts:OptionsPattern[]]:=Plus@@MagnusSeriesList[t,T,n,A,opts]


EvaluateNumericalField[{Field_, toptime_}, {\[CurlyEpsilon]_, T_, t_}][w_] := Module[{k, y, x, x0, x1},
  (w //. HoldIntegrate :>  Sum) /. {T -> toptime, \[CurlyEpsilon][t[k_]] :> Part[Field, t[k]+1]}
  ]


MagnusOrderedIntegralRules[n_,\[CapitalOmega]_,P_]:=Module[{return,p,k,\[Epsilon]},\[Epsilon]/:Power[\[Epsilon],s_?(#>n&)]:=0;
return=DotLog[n][1+Sum[\[Epsilon]^k*P[k],{k,1,n}]];
ClearAll[\[Epsilon]];
MapThread[Rule,{Table[\[CapitalOmega][k],{k,1,n}],Drop[CoefficientList[return,\[Epsilon]],1]}]]


OrderedIntegralRules[n_?IntegerQ,P_,t_,T_,A_]:=Module[{count=1,intlist,k},intlist=NestList[HoldIntegrate[A[t[++count]].#,{t[count],0,t[count+1]}]&,HoldIntegrate[A[t[1]],{t[1],0,t[2]}],n-1];
Table[P[k]->(Part[intlist,k]/.t[k+1]->T),{k,1,n}]]


MagnusOrderedIntegralInvertedRules[n_?IntegerQ,P_,\[CapitalOmega]_]:=Module[{count=2,pre},count=2;
pre=Equal@@#&/@MagnusOrderedIntegralRules[n,\[CapitalOmega],P];
Fold[Join[#1,FullDotSimplify@First@Solve[(#2/.#1),P[count++]]]&,{P[1]->\[CapitalOmega][1]},Rest[pre]]]


MyReplaceList[f_,r_]:=Module[{return},
return=ReplaceList[f,r];
If[return=={},f,return]
]


AllLevelsReplaceList[f_,r_]:=MapAll[  MyReplaceList[#,r]&,f]


RootedTreeExpression[2]:={RootedTree[1,2]}


RootedTreeExpression[n_]:= Module[{x,y,rule,init,pre},
init=NonCommutativeMultiply@@Range[n];
rule= x_**y_-> RootedTree[x,y];

pre=FixedPoint[ AllLevelsReplaceList[#,rule]&, init ]/.List[RootedTree[x__]]->RootedTree[x] ;

Flatten[pre//.{RootedTree[x_,y__List]:> Map[RootedTree[x,#]&,y], RootedTree[x_List,y_]:> Map[RootedTree[#,y]&,x]}]
]


TreeIndexDepth[n_][tree_]:=Module[{k,countL,countR},
countL=0;countR=0;
tree//. {RootedTree[n,_]:> ( countL++;n), RootedTree[_,n]:> n};
tree//. {RootedTree[_,n]:> ( countR++;n), RootedTree[n,_]:> n};
{countL,countR}
]


RootedTreePrimitiveFunction=
{{Thick,Line[{{0,0}+#,{1,1}+#}]},Line[{{0,0}+#,{-1,1}+#,{-1,1}+{0,1}+#}]}&;


RootedTreePrimitiveFunctionTop=
{Line[{{0,0}+#,{1,1}+#}],Point[{1,1}+#],Line[{{0,0}+#,{-1,1}+#,{-1,1}+{0,1}+#}],Point[{-1,2}+#]}&;


makeTopTree[{x_,y_}]:=Module[{},
{PointSize[0.05],Hue[0.7],Point[{-1,2}*x+{1,1}*y]}
]


RootedTreeGraph[rt_,graphOpts___]:=Module[{k,a,b,rule0,rule,pre,RootedTreePrimitiveRule,top},
rule0= RootedTree[a_?IntegerQ,b_?IntegerQ]:> RootedTreePrimitive[{0,0}];
rule= {
RootedTree[RootedTreePrimitive[a_],b_?IntegerQ] :> {RootedTreePrimitive[a+{-1,2}],RootedTreePrimitive[{0,0}]},
RootedTree[b_?IntegerQ,RootedTreePrimitive[a_]] :> {RootedTreePrimitive[{0,0}],RootedTreePrimitive[a+{1,1}]},
RootedTree[RootedTreePrimitive[a_],RootedTreePrimitive[b_]] :> {RootedTreePrimitive[{0,0}],RootedTreePrimitive[a+{-1,2}],RootedTreePrimitive[b+{1,1}]},
RootedTree[a_,b_List]:> Map[ RootedTree[a,#]&,b],
RootedTree[a_List,b_]:> Map[ RootedTree[#,b]& ,a]
};
pre= (rt/.rule0)//.rule;
top=Table[makeTopTree@TreeIndexDepth[k][rt],{k,1,Length@Position[rt,RootedTree]+1 }];
Graphics[
{pre/.RootedTreePrimitive-> RootedTreePrimitiveFunction, top}
,graphOpts,ImageSize->{160,160}]
]


RootedTreeCoefficient[rt_]:=Module[{i,zerort,a,b,c,pre,f,ndiags},
zerort=(rt/. {i_?IntegerQ->0});
pre=f@@zerort//.{ RootedTree[a__,b_?IntegerQ]:> Sequence[a,b+1] };
ndiags=(pre/.f[a__,b_?IntegerQ]:> {a,b+1})/.{0-> Sequence[]};
Times@@Map[BernoulliB[#]/#!&,ndiags]
]


RootedTreeToIntegral[A_,t_,T_][rt_RootedTree]:=Module[
{order,pre,rule0,rule1,preint,k,x,y,return},
order=Length@Position[{rt},RootedTree]+1;
pre=rt/.i_?IntegerQ-> A[t];
rule0=RootedTree[a_,b_]:> Commutator[HoldIntegrate[a,{t,0,t}],b];
rule1= { 
HoldPattern[f[k_][ Commutator[x_,y_]]]:> Commutator[ f[k][x],f[k][y] ],f[k_][HoldIntegrate2[x_,y_]]:> HoldIntegrate2[ f[k-1][x],{t[k-1],0,t[k]} ],
f[k_][A[t]]:> A[t[k]]};
preint=f[order][pre//.rule0]/.HoldIntegrate->HoldIntegrate2;
return=preint//.rule1;
RootedTreeCoefficient[rt]*HoldIntegrate[return/.HoldIntegrate2->HoldIntegrate,{t[order],0,T}]
]


FreeHoldIntegrate[x_]:=Position[{x},HoldIntegrate,{0,Infinity},1]==={}


stackKf[K_,{x_,x0_,x1_},\[CurlyEpsilon]_,f_]:=Module[{func},func=Unique[f];
STACKf=Append[STACKf,((func[x])->K)/.x:>Head@x];
func[x]]


stackKi[K_,{x_,x0_,x1_},g_]:=Module[{func,y,tt},tt=If[AtomQ[x],x,Head[x]];
func=Unique[g];
STACKi=Append[STACKi,(func[x1]->sum[Head@K,x0,x1])/.x1->tt];
func[x1]]


ProcessSTACKf[{\[CurlyEpsilon]_,F_}][w_]:=Module[{headf,bodyf,u,v,s,bodyrule,FF},bodyrule={{u___,Sequence@@Characters[ToString[F]],"(","t",")",s___}->{u,Sequence@@Characters[ToString[F]],"[","t","]",s}};
headf="\ndouble "<>StringJoin[Characters[ToString[First[w]]]/.{"["->"( int ","]"->")"}];
bodyf="{\nreturn "<>StringJoin[Characters[ToString[CForm[Last[w]/.\[CurlyEpsilon]->F]]]/.bodyrule]<>";\n}";
{headf<>";",
StringReplace[StringJoin[{headf,bodyf}],"Power"->"pow"]
}
]


ProcessSTACKi[f_][w_]:=Module[{headf,bodyf,u,v,s,bodyrule},
bodyrule={{u___,Sequence@@Characters[ToString[f]],s___}->{u,"&",Sequence@@Characters[ToString[f]],s}};
headf="\ndouble "<>StringJoin[Characters[ToString[First[w]]]/.{"["->"( int ","]"->")"}];
bodyf="{\nreturn "<>StringJoin[Characters[ToString[CForm[Last[w]]]]/.bodyrule]<>";\n}";
{headf<>";",StringJoin[{headf,bodyf}]}]


CCodeGeneration[{\[CurlyEpsilon]_,F_},{\[Mu]_,M_},{f_,g_}][mags_]:=Module[{K,x,x0,x1,rulef,rulei,newmags,stackf,stacki,extrah,extracc},STACKf={};
STACKi={};
rulef=HoldIntegrate[K_?FreeHoldIntegrate,{x_,x0_,x1_}]:>HoldIntegrate[stackKf[K,{x,x0,x1},\[CurlyEpsilon],f],{x,x0,x1}];
rulei=HoldIntegrate[K_?FreeHoldIntegrate,{x_,x0_,x1_}]:>stackKi[K,{x,x0,x1},g];
(mags/.rulef)/.rulei;
newmags=FixedPoint[((#/.rulef)/.rulei)&,mags];
stacki=Transpose@Map[ProcessSTACKi[f],STACKi];
stackf=Transpose@Map[ProcessSTACKf[{\[CurlyEpsilon],F}],STACKf];

extrah="
double pow(int A, int B);
complex<double> ComplexNumber(double x, double y);
double PrinLieCalc_PrinLieCalc_Private_sum(double (*f)(int t),int ti,int tf);
";
extracc="
double pow(int A, int B){ return pow(double(A), double(B)); }
double PrinLieCalc_PrinLieCalc_Private_sum( double (*f)(int t), int ti, int tf  )
{ double sum=0;
  for(int i = ti ; i<=tf ;i++) sum = sum + (*f)(i);
  return sum;
} \n
complex<double> ComplexNumber(double x, double y)
{ complex<double> z(x,y);
  return z;
}\n";
{
extrah<>Join[Part[stackf,1],Part[stacki,1]]
,
"extern double* "<>ToString[F]<>";\n"<>StringReplace[
"{\n return "<>ToString@CForm[newmags]<>";\n}",
{"Complex"->"ComplexNumber",ToString[\[Mu]]->ToString[M]}]<>extracc<>
Join[Part[stackf,2],Part[stacki,2]]
}
]


CCodeGenerationArmadillo[{\[CurlyEpsilon]_,F_},{\[Mu]_,M_},{f_,g_}][mags_]:=Module[{K,x,x0,x1,rulef,rulei,newmags,stackf,stacki,extrah,extracc,rootFunctionName},STACKf={};
STACKi={};
rulef=HoldIntegrate[K_?FreeHoldIntegrate,{x_,x0_,x1_}]:>HoldIntegrate[stackKf[K,{x,x0,x1},\[CurlyEpsilon],f],{x,x0,x1}];
rulei=HoldIntegrate[K_?FreeHoldIntegrate,{x_,x0_,x1_}]:>stackKi[K,{x,x0,x1},g];
(mags/.rulef)/.rulei;
newmags=FixedPoint[((#/.rulef)/.rulei)&,mags];
stacki=Transpose@Map[ProcessSTACKi[f],STACKi];
stackf=Transpose@Map[ProcessSTACKf[{\[CurlyEpsilon],F}],STACKf];
rootFunctionName= ToString@Unique[MagnusSeries];

extrah="
#include \"/home/cabrer7/Documents/source/C/armadillo/armadillo-0.6.8/include/armadillo\"
#include<complex>
using namespace arma;
using namespace std;
cx_mat "<>rootFunctionName<>"(cx_mat H0, cx_mat M, int T);
cx_mat Commutator(cx_mat A, cx_mat B);
complex<double> ComplexNumber(double x, double y);

double pow(int A, int B);
complex<double> ComplexNumber(double x, double y);
double PrinLieCalc_PrinLieCalc_Private_sum(double (*f)(int t),int ti,int tf);
";
extracc="
#include\"magnus.h\"
#include \"/home/cabrer7/Documents/source/C/armadillo/armadillo-0.6.8/include/armadillo\"

#include<math.h>
#include<complex.h>
extern double*"<> ToString[F]<>";

cx_mat Commutator(cx_mat A, cx_mat B){ return A*B - B*A;}

double pow(int A, int B){ return pow(double(A), double(B)); }

double PrinLieCalc_PrinLieCalc_Private_sum( double (*f)(int t), int ti, int tf  )
{ double sum=0;
  for(int i = ti ; i<=tf ;i++) sum = sum + (*f)(i);
  return sum;
} 

complex<double> ComplexNumber(double x, double y)
{ complex<double> z(x,y);
  return z;}

cx_mat "<>rootFunctionName<>"(cx_mat H0, cx_mat M, int T)
";
{
extrah<>Join[Part[stackf,1],Part[stacki,1]]<>"\n"
,
extracc<>StringReplace[
"{\n return "<>ToString@CForm[newmags]<>";\n}",
{"Complex"->"ComplexNumber",ToString[\[Mu]]->ToString[M]}]<>Join[Part[stackf,2],Part[stacki,2]]<>"\n"
}
]


CCodeGenerationArmadilloList[{\[CurlyEpsilon]_, F_}, {\[Mu]_, M_}, {f_, g_}][mags_List] := Module[
  {count, k, hfile, ccfile, extrah, extracc},
  extrah = "
   #include \"/home/cabrer7/Documents/source/C/armadillo/armadillo-0.6.8/include/armadillo\"
   #include<complex>
   using namespace arma;
   using namespace std;
   
   cx_mat Commutator(cx_mat A, cx_mat B);
   complex<double> ComplexNumber(double x, double y);
   double pow(int A, int B);
   complex<double> ComplexNumber(double x, double y);
   double PrinLieCalc_PrinLieCalc_Private_sum(double (*f)(int t),int ti,int tf);
   ";
  extracc = "
    #include\"magnus.h\"
    #include \"/home/cabrer7/Documents/source/C/armadillo/armadillo-0.6.8/include/armadillo\"
    
    #include<math.h>
    #include<complex.h>
    extern double*" <> ToString[F] <> ";
    
    cx_mat Commutator(cx_mat A, cx_mat B){ return A*B - B*A;}
    
    double pow(int A, int B){ return pow(double(A), double(B)); }
    
    double PrinLieCalc_PrinLieCalc_Private_sum( double (*f)(int t), int ti, int tf  )
    { double sum=0;
      for(int i = ti ; i<=tf ;i++) sum = sum + (*f)(i);
      return sum;
    } 
    
    complex<double> ComplexNumber(double x, double y)
    { complex<double> z(x,y);
      return z;}";
  
  count = 2;
  {hfile, ccfile} = Transpose[
    Table[
     CCodeGenerationArmadilloBase[{\[CurlyEpsilon], F}, {\[Mu], M}, {f, g}, count++]@Part[mags, k], {k, 1, Length[mags]}]
    ];
  
  {extrah <> hfile, extracc <> ccfile}
  ]


CCodeGenerationArmadilloBase[{\[CurlyEpsilon]_, F_}, {\[Mu]_, M_}, {f_, g_}, identif_][mags_] := Module[{K, x, x0, x1, rulef, rulei, newmags, stackf, stacki, extrah, extracc, rootFunctionName, rootFunctiondef}, STACKf = {};
  STACKi = {};
  rulef = HoldIntegrate[K_?FreeHoldIntegrate, {x_, x0_, x1_}] :> HoldIntegrate[stackKf[K, {x, x0, x1}, \[CurlyEpsilon], f], {x, x0, x1}];
  rulei = HoldIntegrate[K_?FreeHoldIntegrate, {x_, x0_, x1_}] :> stackKi[K, {x, x0, x1}, g];
  (mags /. rulef) /. rulei;
  newmags = FixedPoint[((# /. rulef) /. rulei) &, mags];
  stacki = Transpose@Map[ProcessSTACKi[f], STACKi];
  stackf = Transpose@Map[ProcessSTACKf[{\[CurlyEpsilon], F}], STACKf];
  rootFunctionName = "MagnusSeries" <> ToString[identif];
  rootFunctiondef = "cx_mat " <> rootFunctionName <> "(cx_mat H0, cx_mat M, int T)";
  
  {"\n" <> rootFunctiondef <> ";" <> Join[Part[stackf, 1], Part[stacki, 1]] <> "\n",
   "\n" <> rootFunctiondef <> StringReplace[
     "{\n return " <> ToString@CForm[newmags] <> ";\n}",
     {"Complex" -> "ComplexNumber", ToString[\[Mu]] -> ToString[M]}] <> Join[Part[stackf, 2], Part[stacki, 2]] <> "\n"
   }
  ]


CFormString[g_,x_]:=Module[{k,step1,step2,var},
step1=ToString[CForm[g]];
var=ToString[x];
step2=StringReplace[step1,var<>"("~~k_~~")":>var<>"["~~k~~"]"];
StringReplace[step2,{"Power"->"pow","Sin"->"sin","Cos"->"cos","Sqrt"-> "sqrt"}]]


CFormStringMatrix[g_?MatrixQ,x_,G_]:=Module[{j,k,step1,step2,var,n},
n=Length[g];
"#include<math.h>\n
    #include<armadillo>\n 
   using namespace arma;\n
double "<>ToString[G]<>"(int j,int k, rowvec &x)  \n{ "<>"\n switch(j){\n"<>Table["case "<>ToString[j-1]<>":\n"<>"\t switch(k){\n"<>Table["\t case "<>ToString[k-1]<>":\n"<>"\t return "<>CFormString[Part[g,j,k],x]<>";\n\n",{k,1,n}]<>"\t}\n",{j,1,n}]<>"}"<>"\n}\n"
]


MatrixCForm[g_?MatrixQ,x_,G_]:=Module[{j,k,step1,step2,var,n},
n=Length[g];
ToString[G]<>"(int j,int k, double *x)  \n{ "<>"\n switch(j){\n"<>Table["case "<>ToString[j-1]<>":\n"<>"\t switch(k){\n"<>Table["\t case "<>ToString[k-1]<>":\n"<>"\t return "<>CFormString[Part[g,j,k],x]<>";\n\n",{k,1,n}]<>"\t}\n",{j,1,n}]<>"}"<>"\n}\n"
]


StringCForm[g_,var_]:=Module[{k,l,step1,step2,vars=ToString[var]},
step1=ToString[CForm[g]];
step2=StringReplace[step1,{"Power"->"pow","Sin"->"sin","Cos"->"cos","Sqrt"->"sqrt"}];
StringReplace[step2,{
Shortest[vars<>"("~~k_~~")"]:>vars<>"["~~k~~"]",Shortest[vars<>"("~~k_~~l_~~")"]:>vars<>"["~~k~~l~~"]"}]
]

makeCase[var_][expr_,i_]:="\n case "<>ToString[Last@i-1]<>":\n return "<>StringCForm[expr,var]<>";"

makeCase2[ind_][expr_,i_]:="\n\n case "<>ToString[Last@i-1]<>":\n"<>"switch("<>ToString[Part[ind,Length@i+1]]<>")\n {"<>StringJoin@@expr<>"}"


ArrayCForm[w_,var_,indxs_]:=Module[{dims,core,depth},dims=Dimensions[w];
depth=Length@dims;
core=Map[MapIndexed[makeCase[var],#1,{depth-1}]&,w];
"switch("<>ToString[Part[indxs,1]]<>")\n{"<>StringJoin@@Fold[MapIndexed[makeCase2[indxs],#1,{#2}]&,core,Reverse@Range[depth-1]]<>"}"
]


MakeRealCoefficients[w_,{x_,init_,final_}]:=Module[{rul},rul=MapThread[Rule,{Table[x[k],{k,init,final}],Table[Unique[],{final-init+1}]}];
N[w/.rul]/.Reverse/@rul]


Options[BCHExpansionRules]={Method->"Wilcox"};


BCHExpansionRules[n_,{A_?OperatorQ, B_?OperatorQ}, Z_,opts:OptionsPattern[]]:=Module[{},
Which[
OptionValue[Method]=== "Wilcox",BCHExpansionRulesWilcox[n,{A, B}, Z],
OptionValue[Method]=== "Magnus",BCHExpansionRulesMagnus[n,{A, B}, Z]
]
]


BCHExpansionRulesWilcox[n_,{A_?OperatorQ, B_?OperatorQ}, Z_] := Module[{x, y, Zseries, dZseries, poly, s, polyList, count, k, return, expan1, expan2, \[Lambda]}, \[Lambda] /: Power[\[Lambda], s_?(# > n &)] := 0;
  Zseries = Sum[\[Lambda]^k*Z[k], {k, 1, n}];
  dZseries = Sum[k*\[Lambda]^(k - 1)*Z[k], {k, 1, n}];
  expan1 = Table[1/(k + 1)!, {k, 0, n - 1}].NestList[Expand[ad[Zseries][#]] &, dZseries, n - 1];
  expan2 = Table[1/k!, {k, 0, n - 1}].NestList[Expand[\[Lambda]*ad[A][#]] &, B, n - 1];
  poly = Expand[expan1 - expan2 - A];
  polyList = Take[CoefficientList[poly, \[Lambda]], n];
  count = 2;
  return = Expand@Fold[Flatten[{#1, Solve[(#2 /. #1) == 0, Z[count++]]}] &, {Z[1] -> A + B}, Rest@polyList] //. HoldPattern[ad[x_][y_]] :> Commutator[x, y];
  ClearAll[\[Lambda]];
  ArrangeCommutatorArgLeft[A][return]]


BCHExpansionRulesMagnus[n_?IntegerQ,{X_?OperatorQ,Y_?OperatorQ},Z_]:=Module[{HoldIntegrateRule3,PiecewiseIntRule,ReplaceForX,ReplaceForY,HoldIntegrateRule0,HoldIntegrateRule1,HoldIntegrateRule2,a,u,u1,u2,x,y,return,A,t,k},
SetOperator[{A}];
HoldIntegrateRule3=(HoldIntegrate[a_,{u_,1,2}]:> 
HoldIntegrate[ ReplaceForX[a],{u,1,2}]);
PiecewiseIntRule={
HoldPattern[HoldIntegrate[A[t_],{t_,0,1}]]:> Integrate[Y,{t,0,1}],HoldPattern[HoldIntegrate[A[t_],{t_,1,2}]]:> Integrate[X,{t,1,2}]};

ReplaceForX:= (#/.A[t_]:> X&);
ReplaceForY:= (#/.A[t_]:> Y&);

HoldIntegrateRule0={HoldIntegrate[a_,{t_,0,t2_}]:> HoldIntegrate[a,{t,0,1}]+HoldIntegrate[a,{t,1,t2}]};

HoldIntegrateRule1={HoldIntegrate[a_,{t_,0,t2_?(Not@IntegerQ[#]&)}]:> HoldIntegrate[a,{t,0,1}]+HoldIntegrate[a,{t,1,t2}]};

HoldIntegrateRule2 = {
HoldIntegrate[a_,{u_,0,1}]:> 
HoldIntegrate[ ReplaceForY[a],{u,0,1}]
};
return=ReplaceRepeated[
MagnusSeriesList[t,2,n,A,Method->"RootedTree"]/.HoldIntegrateRule0, Join[HoldIntegrateRule1,HoldIntegrateRule2,PiecewiseIntRule]]/.HoldIntegrateRule3;
UnSetOperator[{A}];

MapThread[Rule,{Table[Z[k],{k,1,n}],return/.HoldIntegrate->Integrate//ArrangeCommutatorArgLeft[X]}]
]


Options[BCHExpansionList]={Method->"Wilcox"};


BCHExpansionList[n_,{A_?OperatorQ, B_?OperatorQ},opts:OptionsPattern[]] := Module[{x, y, Z,return},
SetOperator[{Z}];
return= BCHExpansionRules[n,{A, B}, Z,opts] /. Rule[x_, y_] -> y;
UnSetOperator[{Z}];
return
]


WilcoxPolynomial[n_,W_?OperatorQ,\[Epsilon]_]:=Module[{U,V,bch,count,count2,count3,return},\[Epsilon]/:Power[\[Epsilon],_?(#>n&)]:=0;
SetOperator[{U,V}];
bch=BCHExpansionList[n-1,{U,V}];
count=2;
count2=2;
count3=0;
return=Nest[Expand[Plus@@Drop[bch,count3--]/.{U->#,V->(\[Epsilon]^count2++)*W[count++]}]&,\[Epsilon]*W[1],n-1];
ClearAll[\[Epsilon]];
UnSetOperator[{U,V}];
return]


WilcoxFactorizationRules[n_,{W_?OperatorQ,\[CapitalOmega]_?OperatorQ}]:=Module[{ruleInit,wilcoxterms,count,count2,\[Epsilon]},ruleInit={W[1]->\[CapitalOmega][1],W[2]->\[CapitalOmega][2]};
wilcoxterms=Drop[CoefficientList[WilcoxPolynomial[n,W,\[Epsilon]],\[Epsilon]],3];
count=3;
count2=3;
Fold[Flatten[{#1,Solve[(#2/.#1)==\[CapitalOmega][count2++],W[count++]]}]&,ruleInit,wilcoxterms]//ExpandAll]


ForceHermitianConjugation[x_]:=Module[{a,b},Transpose[x]/.Complex[a_,b_]->Complex[a,-b]]


MForceHermitianConjugation[x_]:=Module[{a,b},Transpose[x]/.Complex[a_,b_]->Complex[a,-b]]


ParametrizedCosetLieAlgebraColumnB[{n_?IntegerQ,m_?IntegerQ},B_]:=Module[{noff,k},noff=Sum[2*k,{k,1,m-1}];
Table[{B[k+noff]+I*B[k+1+noff]},{k,1,2*m,2}]]


LieAlgebraCosetB[{n_,m_},B_]:=Module[{mm,M},If[m>=n,Message[LieAlgebraCosetB::badinput] Abort[];];
Fold[(M=ParametrizedCosetLieAlgebraColumnB[{n,#2},B];
If[#2==m,M,M=M*0];
ArrayFlatten[{{#1,M},{-ForceHermitianConjugation[M],{{0}}}}])&,{{0}},Range[n-1]]]


CanonicalCosetLieAlgebra[{n_,m_},B_]:=Module[{mm,M},If[m>=n,Message[CanonicalCosetLieAlgebra::badinput] Abort[];];
Fold[(M=ParametrizedCosetLieAlgebraColumnB[{n,#2},B];
If[#2==m,M,M=M*0];
ArrayFlatten[{{#1,M},{-ForceHermitianConjugation[M],{{0}}}}])&,{{0}},Range[n-1]]]


ParametrizedCosetColumnX[{n_?NumericQ,m_},x_]:=Module[{k,noffset,i},
noffset=Sum[2*k,{k,1,m-1}];
Table[{x[i]+I*x[i+1]},{i,1+noffset,2*(m)+noffset,2}]]


CosetMatrixX::badinput = " Bad input in CosetMatrixX[{n,m},B] ";


CosetMatrixX[{n_?IntegerQ,m_?IntegerQ},x_]:=Module[{columnX,Q11,Q22,Q12,Q21},If[m>=n,Message[CosetMatrixX::badinput] Abort[];];
Print["Obsolete function, use CanonicalCoset instead"];
columnX=ParametrizedCosetColumnX[{n,m},x];
Q11=ArrayFlatten[Simplify[{{MatrixPower[IdentityMatrix[m]-columnX.ForceHermitianConjugation[columnX],1/2],columnX},{-ForceHermitianConjugation[columnX],Sqrt[1-ForceHermitianConjugation[columnX].columnX]}}]];
If[n==m+1,Q11,Q22=Table[1,{n-m-1},{n-m-1}];
Q22=IdentityMatrix[n-m-1];
Q12=Table[Table[0,{n-m-1}],{m+1}];
Q21=Transpose[Q12];
ArrayFlatten[{{Q11,Q12},{Q21,Q22}}]]
]


CanonicalCoset[{n_,m_},x_]:=Module[{PM,r2,X,Xd,Q11,Q12,Q22,Q21},
X=ParametrizedCosetColumnX[{n,m},x];
PM=PermutationMatrix@Reverse@Range[n];
Xd=MForceHermitianConjugation[X];
r2=Tr[Expand[Xd.X]];
Q11=ArrayFlatten[{{IdentityMatrix[m]+(Sqrt[1-r2]-1)/r2*X.Xd,X},{-Xd,Sqrt[1-r2]}}];
If[n==m+1,PM.Q11.Transpose[PM],Q22=Table[1,{n-m-1},{n-m-1}];
Q22=IdentityMatrix[n-m-1];
Q12=Table[Table[0,{n-m-1}],{m+1}];
Q21=Transpose[Q12];
PM.ArrayFlatten[{{Q11,Q12},{Q21,Q22}}].Transpose@PM
]
]


FindOcurrenceVariable::usage="FindOcurrenceVariable[vars_List][expr_], gives a subset of the list of variables vars that appear in expr";

FindOcurrenceVariable[vars_][expr_]:=Module[{pos},pos={Flatten[Position[expr,#]]=!={},#}&/@vars;
Flatten[pos/.{False,_}->Sequence[]]/.True->Sequence[]]


CanonicalCosetLieAlgebraLayer[n_,m_,PM_]:=Module[{P,b,c},P=ArrayFlatten[{{0,Transpose@Table[{1},{m}]},{Table[{1},{m}],Table[0,{m},{m}]}}];
b=Table[0,{m+1},{n-m-1}];
c=Table[0,{n-m-1},{n-m-1}];
If[m==n-1,PM.P.Transpose[PM],PM.ArrayFlatten[{{c,Transpose@b},{b,P}}].Transpose@PM]]


CanonicalCosetLieAlgebraProjector[n_,m_,PM_: Identity][M_]:=((1-Sum[CanonicalCosetLieAlgebraLayer[n,k,PM],{k,n-1,m,-1}])*M)


FidelityLeftGradientU[W_?MatrixQ][U_?MatrixQ]:=1/2 (W.ConjugateTranspose[U]-U.ConjugateTranspose[W])


FidelityRightGradientU[W_?MatrixQ][U_?MatrixQ]:=1/2 (ConjugateTranspose[U].W-ConjugateTranspose[W].U)


NextLeftGradientStepFidelityU[W_,dt_,P_: Identity][U_]:=MatrixExp[P[FidelityLeftGradientU[W][U]]*dt].U


NextRightGradientStepFidelityU[W_,dt_,P_: Identity][U_]:=U.MatrixExp[P[FidelityRightGradientU[W][U]]*dt]


CanonicalCosetRightDecompositionGradient[W_?MatrixQ,PM_?MatrixQ,{ds_?NumberQ,error_?NumberQ}]:=Module[{n,k,temp,CW},n=Length[W];
CW=FoldList[{temp=FixedPoint[NextLeftGradientStepFidelityU[IdentityMatrix[n],ds,CanonicalCosetLieAlgebraProjector[n,#2,PM]],Part[#1,2],SameTest->(Sqrt@Re@Tr[(#1-#2).ConjugateTranspose[#1-#2]]<error&)],Part[#1,2].ConjugateTranspose[temp]}&,{IdentityMatrix[n],W},Table[k,{k,n-1,1,-1}]];
Append[Part[Drop[CW,1],All,1],Last@Last[CW]]]


CanonicalCosetLeftDecompositionGradient[W_?MatrixQ,PM_?MatrixQ,{ds_?NumberQ,error_?NumberQ}]:=Module[{n,k,temp,CW},n=Length[W];
CW=FoldList[{temp=FixedPoint[NextRightGradientStepFidelityU[IdentityMatrix[n],ds,CanonicalCosetLieAlgebraProjector[n,#2,PM]],Part[#1,2],SameTest->(Sqrt@Re@Tr[(#1-#2).ConjugateTranspose[#1-#2]]<error&)],ConjugateTranspose[temp].Part[#1,2]}&,{IdentityMatrix[n],W},Table[k,{k,n-1,1,-1}]];
Append[Part[Drop[CW,1],All,1],Last@Last[CW]]]


Options[UToCanonicalCosetCoordinates]={"Direction"->Left,"Permutation"-> Identity};


UToCanonicalCosetCoordinates[U_?MatrixQ,opts:OptionsPattern[]]:=
Module[{V,i,n=Length[U],cosets,phases,PermM = OptionValue["Permutation"]},
V=Transpose/@CanonicalCosetDecomposition[U,opts];
If[OptionValue["Direction"]===Right , V=Reverse[V]];
If[PermM=!=Identity, V=Map[ Transpose[PermM].#.PermM& ,  V]  ];
cosets=Flatten@Table[Reverse@Drop[Part[V,i,i],i],{i,n-1,1,-1}];
phases=Im@Log@Table[Part[V,n,i,i],{i,1,n}];
Join[Reverse@phases,Flatten[{Re[#],Im[#]}&/@cosets]]]


CanonicalCosetParametrizationLeftU[n_,x_]:=Module[{k,i,PM},
(Dot@@Table[CanonicalCoset[{n,k},x],{k,n-1,1,-1}]).DiagonalMatrix[Reverse@Table[Exp[I*x[i]],{i,n^2-n+1,n^2}]]
]

CanonicalCosetParametrizationRightU[n_,x_]:=Module[{k,i},DiagonalMatrix[Reverse@Table[Exp[I*x[i]],{i,n^2-n+1,n^2}]].(Dot@@Table[CanonicalCoset[{n,k},x],{k,1,n-1}])]


Options[CanonicalCosetParametrizationU]={"Direction"->Left};


CanonicalCosetParametrizationU[n_,x_,opts:OptionsPattern[]]:=
Module[{},
Which[
OptionValue["Direction"]===Left,CanonicalCosetParametrizationLeftU[n,x],
OptionValue["Direction"]===Right,CanonicalCosetParametrizationRightU[n,x]]
]


NParametrizedCosetColumnX[{n_?NumericQ,m_},x_List]:=Module[{k,noffset,i},noffset=Sum[2*k,{k,1,m-1}];
Table[{x[[i]]+I*x[[i+1]]},{i,1+noffset,2*(m)+noffset,2}]]


MyArrayFlatten[Q_?MatrixQ,X_?MatrixQ,R_?MatrixQ]:=Module[{n=Length[Q],m=Length[X],Xd},Xd=ConjugateTranspose[X];
Table[If[i<=m,If[j<=m,Q[[i,j]],X[[i,j-m]]],If[j<=m,-Xd[[i-m,j]],R[[i-m,j-m]]]],{i,1,m+1},{j,1,m+1}]]


NCanonicalCoset[{n_,m_},x_List]:=Module[{PM,r2,X,Xd,Q11,Q12,Q22,Q21,Q11core},PM=PermutationMatrix@Reverse@Range[n];
X=NParametrizedCosetColumnX[{n,m},x];
Xd=ConjugateTranspose[X];
r2=Re@Tr[Expand[Xd.X]];
Q11core=IdentityMatrix[m]+If[r2>10^(-12),(Sqrt[1-r2]-1)/r2*X.Xd,-1/2*X.Xd];
Q11=ArrayFlatten[{{Q11core,X},{-ConjugateTranspose@X,{{Sqrt[1-r2]}}}}];
If[n==m+1,PM.Q11.Transpose[PM],Q22=IdentityMatrix[n-m-1];
Q12=Table[Table[0,{n-m-1}],{m+1}];
Q21=Transpose[Q12];
PM.ArrayFlatten[{{Q11,Q12},{-ConjugateTranspose@Q12,Q22}}].Transpose[PM]]]


CanonicalCosetCoordinatesToU[x0_List]:=Module[{n=Sqrt[Length@x0],cosets,phases},
cosets=Reverse@Table[NCanonicalCoset[{n,k},x0],{k,1,n-1}];
phases=DiagonalMatrix@Reverse@Exp[I*Take[x0,-n]];
Dot@@Append[cosets,phases]]


CanonicalCosetGrapU[U_,opts___]:=Module[{n=Length@U,ccc,k,nodes},ccc=CanonicalCosetDecomposition[U];
nodes=Range[n];
Graphics[Table[MapThread[{Opacity@Abs[#2],Arrowheads[Abs@#2/10],Thickness[Abs@#2/50],#1}&,{Outer[Arrow[{{n-k,#2},{n-k+1,#1}}]&,Sequence@@Table[nodes,{2}]],Part[ccc,k]},2],{k,1,n-1}]]]


CanonicalCosetGrapState[U_,\[Psi]0_,opts___]:=Module[{n=Length@U,ccc,ccc2,k,nodes,\[Psi]List},ccc=Drop[CanonicalCosetDecomposition[U],-1];
nodes=Range[n];
\[Psi]List=Reverse@FoldList[#2.#1&,\[Psi]0,Drop[Reverse[ccc],-1]];
ccc2=MapThread[Times,{Abs@\[Psi]List,ccc},2];
Graphics[Table[MapThread[{Opacity@Abs[#2],Arrowheads[Abs@#2/10],Thickness[Abs@#2/40],#1}&,{Outer[Arrow[{{n-k,#1},{n-k+1,#2}}]&,Sequence@@Table[nodes,{2}]],Part[ccc2,k]},2],{k,n-1,1,-1}]]]


Options[CanonicalCosetDecomposition]={"Direction"->Left,"Permutation"-> Identity,"SubGroup"-> 1};


basisReflection[n_,m_]:=DiagonalMatrix@RotateRight[Prepend[Table[1,{n-1}],-1],m-1]


basisReflectionList[n_]:=Module[{L},
L=Table[basisReflection[n,m],{m,1,n-1}];
Append[L,Dot@@L]]


CCDReflectionList[n_,subGroup_]:=Module[{diag1,RList},
diag1= Prepend[Table[1,{n-1}],-1];
RList=DiagonalMatrix/@NestList[ RotateRight,diag1,n-1-subGroup];
Append[RList,Dot@@RList]
]


CanonicalCosetDecomposition[W_,opts:OptionsPattern[]]:=Module[{n,W2,PM,subGroup},
n=Length[W];

subGroup = OptionValue["SubGroup"];

If[OptionValue["Permutation"]===Identity,PM=IdentityMatrix[n],PM=OptionValue["Permutation"]];

W2=PM.W.Transpose[PM];

Which[
OptionValue["Direction"]===Left,
MapThread[PM.Dot[##].Transpose[PM]&,
{HouseholderLeftDecomposition[W2,subGroup,1],CCDReflectionList[n,subGroup]}],
OptionValue["Direction"]===Right,Reverse@MapThread[PM.Dot[##].Transpose[PM]&,{CCDReflectionList[n,subGroup],Reverse@HouseholderRightDecomposition[W2,subGroup,1]}]]

]


Options[HouseholderDecomposition]={"Direction"->Left,"Sign"->1,"SubGroup"-> 1};


HouseholderDecomposition[W_,opts:OptionsPattern[]]:=
Module[{n,subGroup},
n=Length[W];
subGroup = OptionValue["SubGroup"];
Which[
OptionValue["Direction"]===Left,
Which[
OptionValue["Sign"]===1,HouseholderLeftDecomposition[W,subGroup,1],
OptionValue["Sign"]===-1,HouseholderLeftDecomposition[W,subGroup,-1]
]
,
OptionValue["Direction"]===Right,
Which[
OptionValue["Sign"]===1,HouseholderRightDecomposition[W,subGroup,1],
OptionValue["Sign"]===-1,HouseholderRightDecomposition[W,subGroup,-1]
]
]
]


HouseholderLeftDecomposition[W_,subGroup_,sign_: 1]:=Module[{ee,X,u,v,Q,n,W2,Qs},n=Length[W];
W2=W;
ee=Transpose[List[#]]&/@IdentityMatrix[n];
Qs=Table[X=W2[[All,i]];
u=X+sign*Exp[I*Arg[Part[X,i]]]*Part[ee,i];
Q=IdentityMatrix[n]-2 (1/Re@Tr[ConjugateTranspose[u].u]) u.ConjugateTranspose[u];
W2=Q.W2;
Q,{i,1,n-subGroup}];
Append[Qs,W2]]


HouseholderRightDecomposition[W_,subGroup_, sign_: 1] := Module[{ee, X, u, v, Q, n, W2, Qs}, n = Length[W];
  W2 = W;
  ee = Transpose[List[#]] & /@ IdentityMatrix[n];
  Qs = Table[X = {Part[W2, i]};
    u = X + sign*Exp[I*Arg[Part[First[X], i]]]*Transpose@Part[ee, i];
    Q = IdentityMatrix[n] - 2 (1/Re@Tr[ConjugateTranspose[u].u]) ConjugateTranspose[u].u;
    W2 = W2.Q;
    Q, {i, 1, n - subGroup}];
  Reverse@Append[Qs, W2]
]


CanonicalCosetBallCoordinates[U_]:=Module[{k,n,step},n=Length[U];
step=Table[Drop[Part[CanonicalCosetDecomposition[U,IdentityMatrix[n]],k,k],k],{k,1,n-1}];
Map[Flatten,step/.Complex[a_,b_]:>List[a,b]]]


GCCDX11[X_]:=MatrixPower[IdentityMatrix[Length@Transpose@X]-ConjugateTranspose[X].X,1/2]


BlockCanonicalCoset[X_]:=Module[{XX11,XX22},
XX11=MatrixPower[IdentityMatrix[Length@Transpose@X]-ConjugateTranspose[X].X,1/2];
XX22=MatrixPower[IdentityMatrix[Length@X]-X.ConjugateTranspose[X],1/2];
ArrayFlatten[{{XX11,-ConjugateTranspose@X},{X,XX22}}]
]


RawMatrixToX11[U_]:=Module[{U11,U21,n=Length[U],det1,det2,alt1,alt2},
U11=Take[U,{1,n/2},{1,n/2}];
U21=Take[U,{n/2+1,n},{1,n/2}];
det1=Abs@Det[GCCDX11[U21]];
det2=Abs@Det[U11];
If[N@det1<N@det2,
U21.GCCDX11[U21].Inverse[U11],
     U21.ConjugateTranspose@Inverse[GCCDX11[U21]].ConjugateTranspose[U11]
]
]


Options[BlockCanonicalCosetDecomposition]={"Direction"->Left,"Subgroup"->2};


BlockCanonicalCosetDecomposition[U_,OptionsPattern[]]:=Module[{subgroup},
subgroup = OptionValue["Subgroup"];
Which[
OptionValue["Direction"]===Left,
FullBlockCanonicalCosetDecompositionLeft[subgroup,U],
OptionValue["Direction"]===Right,ConjugateTranspose/@Reverse[FullBlockCanonicalCosetDecompositionLeft[subgroup,ConjugateTranspose@U]]]
]


BlockCanonicalCosetDecompositionLeft[U_]:=Module[{X11,CC},X11=RawMatrixToX11[U];
{CC=GeneralizedCanonicalCoset[X11],ConjugateTranspose[CC].U}]


DistributeGCCD[m_,M_]:=Module[{diags,i},diags=Table[{i,i},{i,1,Length[M]/m}];
{ArrayFlatten@MapAt[First,#,diags],ArrayFlatten@MapAt[Last,#,diags]}&@MapAt[BlockCanonicalCosetDecompositionLeft,Partition[M,{m,m}],diags]]


FullBlockCanonicalCosetDecomposition[subgroup_,U_,OptionsPattern[]]:=Module[{dir},
dir=OptionValue["Direction"];
Which[dir===Left,FullBlockCanonicalCosetDecompositionLeft[subgroup,U],dir===Right,ConjugateTranspose@Reverse[FullBlockCanonicalCosetDecompositionLeft[subgroup,ConjugateTranspose@U]]]]


FullBlockCanonicalCosetDecompositionLeft[subgroup_,U_]:=Module[{dimSequence},
dimSequence=NestWhileList[#/2&,Length@U,#>2*subgroup&];
Flatten[Most[#]&/@(Append[#,Reverse@Last@#]&@FoldList[DistributeGCCD[#2,Last@#1]&,{U},dimSequence]),1]
]


UnitaryConjugateInverse[U_][W_]:=U.W.ConjugateTranspose[U]
UnitaryConjugate[U_][W_]:=ConjugateTranspose[U].W.U


KAKCanonicalCosetDecomposition[U_,nIterations_,T_]:=
Module[{U1,U2,V1,V2,n},n=Length@U;
Nest[Function[{X},{U1,U2}=BlockCanonicalCosetDecomposition[Part[X,2],"Subgroup"->n/2]//Chop[#,10^(-9)]&;
{V1,V2}=ConjugateTranspose@UnitaryConjugateInverse[T]@#&/@Reverse@BlockCanonicalCosetDecomposition[ConjugateTranspose@UnitaryConjugate[T]@U1,"Subgroup"->n]//Chop[#,10^(-9)]&;
{Part[X,1].V1,V2,U2.Part[X,3]}],{IdentityMatrix[n],U,IdentityMatrix[n]},nIterations]]


FactorizeRightQubits[B_]:=Module[{n,G1,G2,S1,S2,ZeroMatrix},
n=Length[B]/2;
G1=Take[B,{1,n},{1,n}];
G2=Take[B,{n+1,2 n},{n+1,2 n}];
S2=MatrixPower[G1.ConjugateTranspose[G2],1/2];
S1=ConjugateTranspose[S2].G1;
ZeroMatrix=0*IdentityMatrix[n];
{ArrayFlatten[{{S2,ZeroMatrix},{ZeroMatrix,ConjugateTranspose[S2]}}],ArrayFlatten[{{S1,ZeroMatrix},{ZeroMatrix,S1}}]}]


GCCDX11[X_]:=MatrixPower[IdentityMatrix[Length@Transpose@X]-ConjugateTranspose[X].X,1/2]


GeneralizedCanonicalCoset[X_]:=Module[{XX11,XX22},
XX11=MatrixPower[IdentityMatrix[Length@Transpose@X]-ConjugateTranspose[X].X,1/2];
XX22=MatrixPower[IdentityMatrix[Length@X]-X.ConjugateTranspose[X],1/2];
ArrayFlatten[{{XX11,-ConjugateTranspose@X},{X,XX22}}]
]


RawMatrixToX11[U_]:=Module[{U11,U21,n=Length[U],det1,det2,alt1,alt2},
U11=Take[U,{1,n/2},{1,n/2}];
U21=Take[U,{n/2+1,n},{1,n/2}];
det1=Abs@Det[GCCDX11[U21]];
det2=Abs@Det[U11];
If[N@det1<N@det2,
U21.GCCDX11[U21].Inverse[U11],
     U21.ConjugateTranspose@Inverse[GCCDX11[U21]].ConjugateTranspose[U11]
]
]


Options[GeneralizedCanonicalCosetDecomposition]={"Direction"->Left,"Subgroup"->4};


GeneralizedCanonicalCosetDecomposition[U_,OptionsPattern[]]:=Module[{subgroup},
subgroup = OptionValue["Subgroup"];
Which[
OptionValue["Direction"]===Left,
FullGeneralizedCanonicalCosetDecompositionLeft[subgroup,U],
OptionValue["Direction"]===Right,ConjugateTranspose/@Reverse[FullGeneralizedCanonicalCosetDecompositionLeft[subgroup,ConjugateTranspose@U]]]
]


GeneralizedCanonicalCosetDecompositionLeft[U_]:=Module[{X11,CC},X11=RawMatrixToX11[U];
{CC=GeneralizedCanonicalCoset[X11],ConjugateTranspose[CC].U}]


DistributeGCCD[m_,M_]:=Module[{diags,i},diags=Table[{i,i},{i,1,Length[M]/m}];
{ArrayFlatten@MapAt[First,#,diags],ArrayFlatten@MapAt[Last,#,diags]}&@MapAt[GeneralizedCanonicalCosetDecompositionLeft,Partition[M,{m,m}],diags]]


FullGeneralizedCanonicalCosetDecomposition[subgroup_,U_,OptionsPattern[]]:=Module[{dir},dir=OptionValue["Direction"];
Which[dir===Left,FullGeneralizedCanonicalCosetDecompositionLeft[subgroup,U],dir===Right,ConjugateTranspose@Reverse[FullGeneralizedCanonicalCosetDecompositionLeft[subgroup,ConjugateTranspose@U]]]]


FullGeneralizedCanonicalCosetDecompositionLeft[subgroup_,U_]:=Module[{dimSequence},
dimSequence=NestWhileList[#/2&,Length@U,#>subgroup&];
Flatten[Most[#]&/@(Append[#,Reverse@Last@#]&@FoldList[DistributeGCCD[#2,Last@#1]&,{U},dimSequence]),1]
]


Options[RightQubitExtractionU8]={"Direction"-> Left};


RightQubitExtractionU8[U_,OptionsPattern[]]:=Module[{dir},
dir=OptionValue["Direction"];
Which[
dir===Left,RightQubitExtractionU8Left[U],
dir===Right, ConjugateTranspose/@Reverse[RightQubitExtractionU8Left[ConjugateTranspose@U]]
]
]


RightQubitExtractionBlockDiagonalU8Left[U_]:=Module[{return,H,G,B,A,blocks,Z1,Z2,Z3,Z4,a,iH},
{Z1,Z2,Z3,Z4}=Table[Part[Partition[ U ,{2,2}],i,i],{i,1,4}];
H = ConjugateTranspose[MatrixPower[Z3.ConjugateTranspose[Z1].MatrixPower[Z1.ConjugateTranspose[Z3].Z2.ConjugateTranspose[Z4],1/2],1/2]];
G = MatrixPower[ConjugateTranspose[H].Z1.ConjugateTranspose[Z3].ConjugateTranspose[H],1/2];
B = MatrixPower[ConjugateTranspose[G].ConjugateTranspose[H].Z1.ConjugateTranspose[ConjugateTranspose[G].H.Z2],1/2];
A =B.ConjugateTranspose[G].H.Z2;
blocks={{H.G.B,
ConjugateTranspose[H].G.ConjugateTranspose[B],
ConjugateTranspose[H].ConjugateTranspose[G].B,
H.ConjugateTranspose[G].ConjugateTranspose[B]},{A,A,A,A}};
return=ArrayFlatten@Table[ 
If[i===j,Part[#,i],0*IdentityMatrix[2]]
,{i,1,4},{j,1,4}]&/@blocks
]


RightQubitExtractionU8Left[U_]:=Module[{blockU8,GCCD,rq},
GCCD=GeneralizedCanonicalCosetDecomposition[U];
blockU8=Last@GCCD;
rq=RightQubitExtractionBlockDiagonalU8Left[blockU8];
{(Dot@@Drop[GCCD,-1]).First[rq],Last@rq}
]


(T12={{1,0,0,0,0,0,0,0},{0,0,1,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,0,1,0,0,0,0},{0,0,0,0,1,0,0,0},{0,0,0,0,0,0,1,0},{0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,1}});


(T13={{1,0,0,0,0,0,0,0},{0,0,0,0,1,0,0,0},{0,1,0,0,0,0,0,0},{0,0,0,0,0,1,0,0},{0,0,1,0,0,0,0,0},{0,0,0,0,0,0,1,0},{0,0,0,1,0,0,0,0},{0,0,0,0,0,0,0,1}});


QubitExtractionU8Left[U_, n_] := Module[{rq1},
  rq1 = RightQubitExtractionU8Left[U];
  Which[
   n === 1, RightQubitExtractionU8Left[U],
   n === 2,
   Map[
    Transpose[T12].#.T12 &, RightQubitExtractionU8Left[T12.U.Transpose[T12]]
    ],
   n === 3,
   Map[
    Transpose[T13].#.T13 &, RightQubitExtractionU8Left[T13.U.Transpose[T13]]
    ]
   ]
  ]


SingleQubitExtractionStepU8Left[U_]:=Module[{u},
Most@Fold[
{ u=QubitExtractionU8Left[First@#1,#2];First@u, Last[u],Sequence@@Rest[#1]}&,
{U,IdentityMatrix[8]},
{1,2,3}]
]


SingleQubitExtractionU8Left[U_,iter_]:=Module[{pre},
pre=NestList[
SingleQubitExtractionStepU8Left[First@#]&,{U,IdentityMatrix[8],IdentityMatrix[8],IdentityMatrix[8]},
iter];
{  First@Last[pre] ,Sequence@@MapThread[ Dot, Reverse@Take[pre,All,{2,4}]  ]}
]


Options[SingleQubitExtractionU8]={"Direction"-> Left,"Qubit"-> All,"Iterations"-> 4}


SingleQubitExtractionU8[U_,OptionsPattern[]]:=Module[{opt,qubit,iter},
opt= OptionValue["Direction"];
qubit =OptionValue["Qubit"];
iter=OptionValue["Iterations"];
Which[
opt===Left&&qubit===All,SingleQubitExtractionU8Left[U,iter],
opt===Right&&qubit===All,ConjugateTranspose/@Reverse[SingleQubitExtractionU8Left[ ConjugateTranspose@U ,iter]],
opt===Left, QubitExtractionU8Left[U, qubit],
opt===Right,ConjugateTranspose/@Reverse[QubitExtractionU8Left[ConjugateTranspose@U, qubit]]
]
]


Options[RightQubitExtractionU4] = {"Direction" -> Left};


RightQubitExtractionU4[U_,OptionsPattern[]]:=Module[{dir,qubit},
dir=OptionValue["Direction"];
Which[
dir===Left,RightQubitExtractionU4Left[U],
dir===Right, ConjugateTranspose/@Reverse[RightQubitExtractionU4Left[ConjugateTranspose@U]]
]
]


RightQubitExtractionBlockDiagonalU4Left[U_]:=Module[{XX,YY,A,B},
XX=Take[U,{1,2},{1,2}];
YY = Take[U,{3,4},{3,4}];
A=Inverse@MatrixPower[YY.Inverse@XX,1/2] ;
B=Inverse[A].XX;
{
ArrayFlatten[{{ A, 0*IdentityMatrix[2] },{0*IdentityMatrix[2],Inverse[A]}}]
,
ArrayFlatten[{{ B, 0*IdentityMatrix[2] },{0*IdentityMatrix[2],B}}]
}
]


RightQubitExtractionU4Left[U_]:=Module[{blockU4,GCCD,rq},
GCCD=GeneralizedCanonicalCosetDecomposition[U];
blockU4=Last@GCCD;
rq=RightQubitExtractionBlockDiagonalU4Left[blockU4];
{(Dot@@Drop[GCCD,-1]).First[rq],Last@rq}
]


QubitExtractionU4Left[U_, n_] := Module[{rq1,T},
T={{1,0,0,0},{0,0,1,0},{0,1,0,0},{0,0,0,1}};
  rq1 = RightQubitExtractionU4Left[U];
  Which[
   n === 1, RightQubitExtractionU4Left[U],
   n === 2,
   Map[
    Transpose[T].#.T &, RightQubitExtractionU4Left[T.U.Transpose[T]]
    ]
   ]
  ]


SingleQubitExtractionStepU4Left[U_]:=Module[{u},
Most@Fold[
{ u=QubitExtractionU4Left[First@#1,#2];First@u, Last[u],Sequence@@Rest[#1]}&,
{U,IdentityMatrix[4]},
{1,2}]
]


SingleQubitExtractionU4Left[U_,iter_]:=Module[{pre},
pre=NestList[
SingleQubitExtractionStepU4Left[First@#]&,{U,IdentityMatrix[4],IdentityMatrix[4]},
iter];
{  First@Last[pre] ,Sequence@@MapThread[ Dot, Reverse@Take[pre,All,{2,3}]  ]}
]


Options[SingleQubitExtractionU4]={"Direction"-> Left,"Qubit"->All,"Iterations"-> 4}


SingleQubitExtractionU4[U_,OptionsPattern[]]:=Module[{option,return,qubit,iter},
option= OptionValue["Direction"];
qubit = OptionValue["Qubit"];
iter = OptionValue["Iterations"];
Which[
qubit===All&&option===Left,SingleQubitExtractionU4Left[U,iter],
qubit===All&&option===Right,ConjugateTranspose/@Reverse[SingleQubitExtractionU4Left[ConjugateTranspose[U],iter]],
option===Left,QubitExtractionU4Left[U, qubit],
option===Right, ConjugateTranspose/@Reverse[QubitExtractionU4Left[ConjugatetTranspose[U], qubit]]
]
]


HermitianMatrixIndependentTerms[M_?MatrixQ]:=Module[{n=Length[M],i,cc,cc2},cc=Flatten@Table[Reverse@Take[Part[Transpose[M],n-i],{n-i+1,n}],{i,1,n-1}];
cc2=Flatten[{ForceRe[#],ForceIm[#]}&/@Expand[cc]];
Join[cc2,Reverse@Expand[-I*Tr[M,List]]]]


NHaarMetric[U_]:=Module[{dx=10^(-9),dxList,n,x0,k,phases,cosets,dAList,T},n=Length[U];
dxList=dx*NestList[RotateRight,Prepend[Table[0,{n^2-1}],1],n^2-1];
x0=UToCanonicalCosetCoordinates[U];
dAList=1/dx*Map[ConjugateTranspose[U].(CanonicalCosetCoordinatesToU[x0+#]-U)&,dxList];
T=Transpose[HermitianMatrixIndependentTerms/@dAList];
Re[Transpose[T].T]
]


SimpsonRuleIntegrationList[f_List,h_]:=Module[{n,int},n=Length[f];
If[OddQ[n]==True,int=h/3*(First@f+Last@f+2*Sum[Part[f,2*j-1],{j,2,(n-1)/2}]+4*Sum[Part[f,2*j],{j,1,(n-1)/2}]),Print["Error: List length must be odd"];];
int]


PhaseUnfold[ph_List]:=Module[{dP=0,thres=2},Fold[Which[#2+dP-Last@#1>thres,dP-=2 Pi;Append[#1,#2+dP],#2+dP-Last@#1<-thres,dP+=2 Pi;Append[#1,#2+dP],True,Append[#1,#2+dP]]&,{First[ph]},Rest@ph]]


NHaarVelocity[UList_,ds_]:=Module[{prex,x,dx,gList,xMean},
prex = Transpose@Map[UToCanonicalCosetCoordinates,UList];
x= Transpose@Fold[MapAt[PhaseUnfold,#1,#2]&,prex,{7,8,9}];
dx=Drop[x,1]-Drop[x,-1];
gList=Map[NHaarMetric,Drop[UList,1]];
Sqrt@MapThread[#1.#2.#1&,{dx,gList}]/ds
]


NHaarArcLength[UList_List]:=Module[{velocity,ds=1},
velocity=NHaarVelocity[UList,ds];
SimpsonRuleIntegrationList[velocity,ds]
]


BuresVolume[N_]=\[Pi]^(N^2/2)/2^(N^2-1)/Gamma[N^2/2];


insideBall[x_]:=Module[{},If[x.x<=1,x,Sequence[]]]


SurroundingNeighborhood[n_]:=Module[{},Flatten[Permutations/@UpperTriangularize@Table[1,{n},{n}],1];
Flatten[Map[Permutations,Flatten[Function[{X},Union@FoldList[ReplacePart[#1,#2->-Sign[Part[#1,#2]]]&,X,Range@Length[X]]]/@UpperTriangularize@Table[1,{n},{n}],1]],1]]


MCommutator[A_?MatrixQ,B_?MatrixQ]:=A.B-B.A;


MAntiCommutator[A_?MatrixQ,B_?MatrixQ]:=A.B+B.A;


MatrixLeftProjector[n_]:=Map[PadRight[#,n,0]&,Prepend[Array[{0}&,n-1],{1}]]


SelectDiagonalMatrices[M_]:=Part[Transpose[({#,Tr[#,List,2]}&/@M)/.{_,{0..}}->Sequence[]],1]


MHermitianConjugation[x_]:=Conjugate@Transpose[x];


MForceHermitianConjugation[x_]:=Module[{a,b},Transpose[x]/.Complex[a_,b_]-> Complex[a,-b]]


ForceRe[x_]:=(x+(x/.Complex[a_,b_]-> Complex[a,-b]))/2


ForceIm[x_]:=(x-(x/.Complex[a_,b_]-> Complex[a,-b]))/(2*I)//Expand


RightPartialTr[M_]:=Module[{},Map[Tr,Partition[M,{2,2}],{2}]]


LeftPartialTr[M_]:=Module[{},(#[[1,1]]+#[[2,2]]&)@Partition[M,{Length[M]/2,Length[M]/2}]]


EntropyS[L_]:=((-Plus@@(#*ZLog[#]&/@L))/.{0*ZLog[0]->0,0.*ZLog[0.]->0})/.ZLog->Log;


MHermitianPart[a_]:=(a+MHermitianConjugation@a)/2


MAntiHermitianPart[a_]:=(a-MHermitianConjugation@a)/2


TracelessPart[nDim_][x_]:=x-IdentityMatrix[nDim]*Tr[x]/nDim


LocalComponent[nQ_][w_]:=(Tr[w.#]&/@SeparableNQLieALgebra[nQ]).SeparableNQLieALgebra[nQ]/2^nQ


LocalDiagonalizerU[n_][SepState_]:=KroneckerProduct@@(Transpose/@Map[#/Sqrt[#.Conjugate[#]]&,Eigenvectors/@Through[Map[Composition@@Drop[#,n-1]&,NestList[RotateRight,Join[Table[LeftPartialTr[#]&,{n-1}],Table[RightPartialTr[#]&,{n-1}]],2]]@SepState],{n-1}])


MatrixCos[M_]:= (MatrixExp[I*M]+MatrixExp[-I*M])/2


MatrixSin[M_]:= (MatrixExp[I*M]-MatrixExp[-I*M])/(2*I)


LinearlyIndependentMatricesQ[M_]:=Module[{rank,q},
q=Flatten/@M;
rank=MatrixRank[q];
If[rank==Length@M,True,False]];


CompleteLieAlgebra[M_] := 
 Module[{n = Length@M, i, j, iMax, L, candidateElement,candidateL},
  L = M; j = 1; iMax = n;
  While[ j < iMax ,
i = j + 1;
While[i <= iMax,
candidateElement=MCommutator[L[[j]],L[[i]]];i++;
candidateL = Append[L, candidateElement];
If[
LinearlyIndependentMatricesQ[ candidateL ],
iMax++;L = candidateL];
];
 j++; 
];
L
]


deconvoluteCommutators[L_]:=Module[{i,j,f},FixedPoint[#/.{i_,j_}:>f[Part[#,i],Part[#,j]]&,L]/.f->List]


CompleteLieAlgebra[M_, IndexedLieAlgebra -> True] := Module[
  {n = Length@M, i, j, iMax, L, Ltemp, indexList},
  L = M; j = 1; iMax = n;
  indexList = Range[n];
  
  While[ j < iMax ,
   i = j + 1;
   While[i <= iMax,
     Ltemp=MCommutator[L[[j]],L[[i]]];
    i++;
    If[ LinearlyIndependentMatricesQ[ Append[L, Ltemp] ],
      iMax++; L = Append[L, Ltemp]; 
     indexList = Append[indexList, {j, i-1}] ];
    ]; j++; 
    ];
  Transpose[{L, deconvoluteCommutators@indexList}]
  ]


CartanDecompositionQ[t_List,p_List]:=Module[{pp,pt,tt},
pt=Simplify@Flatten[Outer[MCommutator,p,t,1],1];Print["pt"];
tt=Simplify@Flatten[Outer[MCommutator,t,t,1],1]; Print["tt"];
pp=Simplify@Flatten[Outer[MCommutator,p,p,1],1];Print["pp"];
{MatchQ[Flatten@Outer[Tr[#1.#2]&,tt,p,1],{0..}],MatchQ[Flatten@Outer[Tr[#1.#2]&,pt,t,1],{0..}],MatchQ[Flatten@Outer[Tr[#1.#2]&,pp,p,1],{0..}]}]


PauliMatrixToParavector[x_]:=Module[{\[Sigma]1,\[Sigma]2,\[Sigma]3},
\[Sigma]1={{0,1},{1,0}};
\[Sigma]2={{0,-I},{I,0}};
\[Sigma]3={{1,0},{0,-1}};
{Tr[x]/2,Tr[x.\[Sigma]1]/2,Tr[x.\[Sigma]2]/2,Tr[x.\[Sigma]3]/2}]


PauliMatrixToVector[x_]:=Module[{\[Sigma]1,\[Sigma]2,\[Sigma]3},
\[Sigma]1={{0,1},{1,0}};
\[Sigma]2={{0,-I},{I,0}};
\[Sigma]3={{1,0},{0,-1}};
{Tr[x.\[Sigma]1]/2,Tr[x.\[Sigma]2]/2,Tr[x.\[Sigma]3]/2}]


VectorToPauliMatrix[v_]:=Module[{\[Sigma]1,\[Sigma]2,\[Sigma]3},
\[Sigma]1={{0,1},{1,0}};
\[Sigma]2={{0,-I},{I,0}};
\[Sigma]3={{1,0},{0,-1}};
v[[1]]*\[Sigma]1+v[[2]]*\[Sigma]2+v[[3]]*\[Sigma]3]


ParavectorToPauliMatrix[v_]:=Module[{\[Sigma]1,\[Sigma]2,\[Sigma]3},
\[Sigma]1={{0,1},{1,0}};
\[Sigma]2={{0,-I},{I,0}};
\[Sigma]3={{1,0},{0,-1}};
v[[1]]*IdentityMatrix[2]+v[[2]]*\[Sigma]1+v[[3]]*\[Sigma]2+v[[4]]*\[Sigma]3]


ExtractHermitianMatrixComponents[w_]:=Module[{k},Flatten@Table[Take[Part[w,k],k],{k,1,Length@w}]]


NormalRandomComplex[]:=(#[[1]]+#[[2]]*I)&@RandomReal[MultinormalDistribution[{0,0},{{1,0},{0,1}}]]

RandomUnitaryMatrix[n_]:=Module[{z,q,r},z=Table[NormalRandomComplex[],{n},{n}];
{q,r}=QRDecomposition[z];
q.DiagonalMatrix[Sign[Tr[r,List]]]]


RandomOrthogonalMatrix[n_]:=Module[{z,q,r},
z=Table[ RandomReal[NormalDistribution[0,1]],{n},{n}];
{q,r}=QRDecomposition[z];
q.DiagonalMatrix[Sign[Tr[r,List]]]]


RandomSUnitaryMatrix[n_]:=Module[{u},
u=RandomUnitaryMatrix[n];
u*(Det[u]^(-1/n))
]


RandomSeparableNQubitUnitaryMatrix[n_]:=Module[{},
KroneckerProduct@@Table[RandomUnitaryMatrix[2],{n}]
]


MetropolisSampling[f_,xinit_,dx_,n_]:=Module[{x1,x0,a,S,count,basecount},count=1;
basecount=1;
x0=xinit;
S=Range[n];
While[count<=n,basecount++;
If[basecount==10*n,Break[]];
x1=(RandomReal[]-1/2+x0)*dx;
a=f[x1]/f[x0];
If[a<1,If[a<RandomReal[],x0,x0=x1;S[[count++]]=x1;],x0=x1;S[[count++]]=x1;]];
{S,count,basecount}]


GibbsSampling[f_,xinit_,dx_,n_]:=Module[{m,x0,g,i,x},m=Length[xinit];
x0=xinit;
Table[i=RandomChoice[Range[m]];
g=Function[{x},Evaluate[f@@ReplacePart[x0,i->x]]];
x0=ReplacePart[x0,i->Part[MetropolisSampling[g,Part[x0,i],dx,1],1,1]],{n}]]


RandomSpherePoint[dim_]:=Module[{},
#/Sqrt[#.#]&@Table[Random[NormalDistribution[0,1]],{dim}]
]


RandomBallPoint[dim_]:=Module[{randSph,r},
randSph = RandomSpherePoint[dim];
r = Power[Random[],1/dim];
randSph*r
]


M\[Sigma]x[nQ_,i_]:=KroneckerProduct@@RotateRight[Join[{{{0,1},{1,0}}},Table[IdentityMatrix[2],{nQ-1}]],i-1]


M\[Sigma]y[nQ_,i_]:=KroneckerProduct@@RotateRight[Join[{{{0,-I},{I,0}}},Table[IdentityMatrix[2],{nQ-1}]],i-1]


M\[Sigma]z[nQ_,i_]:=KroneckerProduct@@RotateRight[Join[{{{1,0},{0,-1}}},Table[IdentityMatrix[2],{nQ-1}]],i-1]


uNQLieALgebra[nQ_]:= Module[{s,KP},
s[0]={{1,0},{0,1}};
s[1]={{0,1},{1,0}};
 s[2]={{0,-I},{I,0}};
s[3]={{1,0},{0,-1}};
Flatten[Nest[  
Outer[KroneckerProduct,#,{r[0],r[1],r[2],r[3]}]&,{r[0],r[1],r[2],r[3]},nQ-1]]/.r->s
]


suNQLieALgebra[nQ_]:=Drop[ uNQLieALgebra[nQ],1]


uNCoefficients[nQ_][w_]:=(Tr[w.#]&/@uNQLieALgebra[nQ])/2^nQ


USpBasis[n_] := Module[{m, q, k, M, R},
M = Table[ q = m = 0*IdentityMatrix[n];
m[[k,k+1]]=1;m[[n-k+1,n-k]]=1;
m - q, {k, 1, Floor[n/2]}];
R = Table[
 q = m = 0*IdentityMatrix[n];
m[[k,k+1]]=1;m[[n-k+1,n-k]]=1;
 m + q, 
{k, 1, Floor[n/2]}];
  Join[# - Transpose[#] & /@ M, I*# + I*Transpose[#] & /@ R]
   ] /. {2 -> 1, -2 -> -1}


ChevalleyMatrix[N_,{j_,k_}]:=Module[{p,q},Table[KroneckerDelta[p,j]*KroneckerDelta[k,q],{p,1,N},{q,1,N}]]


ChevalleyOffDiagonalBasis[N_]:=Module[{i,j,p,q},Join[Flatten[Table[Table[ChevalleyMatrix[4,{j,k}]-ChevalleyMatrix[4,{k,j}],{j,1,k-1}],{k,1,N}],1],Flatten[Table[Table[I*(ChevalleyMatrix[4,{j,k}]+ChevalleyMatrix[4,{k,j}]),{j,1,k-1}],{k,1,N}],1]]]


RightPartialTranspose2Q[w_]:=Module[{r,s},s[0]={{1,0},{0,1}};
s[1]={{0,1},{1,0}};
s[2]={{0,-I},{I,0}};
s[3]={{1,0},{0,-1}};
uNCoefficients[2][w].Flatten[Nest[Outer[KroneckerProduct,#,{r[0],r[1],-r[2],r[3]}]&,{r[0],r[1],r[2],r[3]},1]]/.r->s]


NegativityEntanglement2Q[w_]:=Module[{},Abs[Plus@@Select[Eigenvalues@RightPartialTranspose2Q[w],#<0&]]]


MPrimitiveProjector[n_][j_]:=Module[{},DiagonalMatrix[RotateRight[Prepend[Table[0,{n-1}],1],j-1]]]


MQubitPrimitiveProjector[signs_List]:=Module[{},
Module[{nQ},
nQ=Length[signs];
Dot@@Map[IdentityMatrix[2^nQ]+#&,Table[M\[Sigma]z[nQ,i],{i,1,nQ}]*signs]/2^nQ]
]


SeparableNQLieALgebra[nQ_]:=Join[Table[M\[Sigma]x[nQ,i],{i,1,nQ}],Table[M\[Sigma]y[nQ,i],{i,1,nQ}],Table[M\[Sigma]z[nQ,i],{i,1,nQ}]]


GellMannSUNGenerators[n_]:=GellMannMatrices[n]


GellMannMatrices[n_]:=Module[{g1,g2,g3,gList},g1=Flatten[Table[Table[Table[KroneckerDelta[j,\[Mu]] KroneckerDelta[i,\[Nu]]+KroneckerDelta[j,\[Nu]] KroneckerDelta[i,\[Mu]],{\[Mu],1,n},{\[Nu],1,n}],{i,1,j-1}],{j,2,n}],1];
g2=Flatten[Table[Table[Table[I (KroneckerDelta[j,\[Mu]] KroneckerDelta[i,\[Nu]]-KroneckerDelta[j,\[Nu]] KroneckerDelta[i,\[Mu]]),{\[Mu],1,n},{\[Nu],1,n}],{i,1,j-1}],{j,2,n}],1];
g3=Join[Table[Sqrt[2/(k^2-k)]*DiagonalMatrix[Join[Table[1,{j,2,k}],{1-k},Table[0,{j,k+1,n}]]],{k,2,n}]];
gList=Flatten[Transpose[{g1,g2}],1];
Do[gList=Insert[gList,Part[g3,j-1],j^2-1],{j,2,n}];
gList]


GellMannProjection[ind_List][M_]:=Module[{n=Length[M],G},
G=Prepend[GellMannMatrices[n], Sqrt[2/3]*IdentityMatrix[n]];
Plus@@Map[1/2*Part[G,#]*Tr[M.Part[G,#]]&,ind+1] 
]


dU[\[Phi]_,d\[Phi]_,\[Phi]Range_,\[Lambda]Sequence_,n_]:=DaggerUdU[\[Phi],d\[Phi],\[Phi]Range,\[Lambda]Sequence,n]


dUd\[Phi][\[Phi]_,d\[Phi]_,\[Phi]Range_,\[Lambda]Sequence_,n_][k_]:=DaggerUdUd\[Phi][\[Phi],d\[Phi],\[Phi]Range,\[Lambda]Sequence,n][k]


DaggerUdUd\[Phi][\[Phi]_, d\[Phi]_, \[Phi]Range_, \[Lambda]Sequence_, n_Integer][k_] := Module[{\[Phi]L, \[Lambda]gen},
  \[Phi]L = \[Phi]@u[#] & /@ \[Phi]Range;
  \[Lambda]gen = Part[GellMannMatrices[n], #] & /@ \[Lambda]Sequence;
  Fold[ExpToTrig[MatrixExp[-I*#2].#1.MatrixExp[I*#2]] &, \[Lambda]gen[[k - First@\[Phi]Range + 1]], Reverse@Take[\[Lambda]gen*\[Phi]L, k - First@\[Phi]Range]]*d\[Phi]@u[k]]


DaggerUdU[\[Phi]_, d\[Phi]_, \[Phi]Range_, \[Lambda]Sequence_, n_Integer] := Plus @@ Map[DaggerUdUd\[Phi][\[Phi], d\[Phi], \[Phi]Range, \[Lambda]Sequence, n], \[Phi]Range]


dVolumeU[\[Phi]_, d\[Phi]_, \[Phi]Range_, \[Lambda]Sequence_, n_Integer] := Module[{d\[Phi]L, LsuN, coef,dA},
 LsuN = GellMannMatrices[n];
d\[Phi]L = d\[Phi]@u[#] & /@ \[Phi]Range;
dA = DaggerUdU[\[Phi], d\[Phi], \[Phi]Range, \[Lambda]Sequence, n];
coef = TrigExpand@(1/2 Tr[dA.LsuN[[#]]] & /@ \[Phi]Range);-Det@Part[Map[Normal@CoefficientArrays[#, d\[Phi]L] &, coef], All, 2]]


DaggerUdUd\[Phi][\[Phi]_,d\[Phi]_,\[Phi]Range_,\[Lambda]Sequence_,lieA_List][k_]:=Module[{\[Phi]L,\[Lambda]gen},\[Phi]L=\[Phi]@u[#]&/@\[Phi]Range;
\[Lambda]gen=Part[lieA,#]&/@\[Lambda]Sequence;
Fold[ExpToTrig[MatrixExp[-I*#2].#1.MatrixExp[I*#2]]&,\[Lambda]gen[[k-First@\[Phi]Range+1]],Reverse@Take[\[Lambda]gen*\[Phi]L,k-First@\[Phi]Range]]*d\[Phi]@u[k]]

DaggerUdU[\[Phi]_,d\[Phi]_,\[Phi]Range_,\[Lambda]Sequence_,lieA_List]:=Plus@@Map[DaggerUdUd\[Phi][\[Phi],d\[Phi],\[Phi]Range,\[Lambda]Sequence,lieA],\[Phi]Range]

dVolumeU[\[Phi]_,d\[Phi]_,\[Phi]Range_,\[Lambda]Sequence_,lieA_List,trNorm_:2]:=Module[{d\[Phi]L,LsuN,coef,dA},d\[Phi]L=d\[Phi]@u[#]&/@\[Phi]Range;
dA=DaggerUdU[\[Phi],d\[Phi],\[Phi]Range,\[Lambda]Sequence,lieA];
coef=TrigExpand@(1/trNorm Tr[dA.lieA[[#]]]&/@\[Phi]Range);
-Det@Part[Map[Normal@CoefficientArrays[#,d\[Phi]L]&,coef],All,2]]


DaggerUdUd\[Phi][\[Phi]L_List,d\[Phi]_,\[Phi]Range_,\[Lambda]Sequence_,lieA_List][k_]:=Module[{\[Lambda]gen},
\[Lambda]gen=Part[lieA,#]&/@\[Lambda]Sequence;
Fold[ExpToTrig[MatrixExp[-I*#2].#1.MatrixExp[I*#2]]&,\[Lambda]gen[[k-First@\[Phi]Range+1]],Reverse@Take[\[Lambda]gen*\[Phi]L,k-First@\[Phi]Range]]*d\[Phi]@u[k]];

DaggerUdU[\[Phi]L_List,d\[Phi]_,\[Phi]Range_,\[Lambda]Sequence_,lieA_List]:=
Plus@@Map[DaggerUdUd\[Phi][\[Phi]L,d\[Phi],\[Phi]Range,\[Lambda]Sequence,lieA],\[Phi]Range];

dVolumeU[\[Phi]L_List,d\[Phi]_,\[Phi]Range_,\[Lambda]Sequence_,lieA_List,trNorm_:2]:=Module[{d\[Phi]L,LsuN,coef,dA},d\[Phi]L=d\[Phi]@u[#]&/@\[Phi]Range;
dA=DaggerUdU[\[Phi]L,d\[Phi],\[Phi]Range,\[Lambda]Sequence,lieA];
coef=TrigExpand@(1/trNorm Tr[dA.lieA[[#]]]&/@\[Phi]Range);
-Det@Part[Map[Normal@CoefficientArrays[#,d\[Phi]L]&,coef],All,2]]


IgnoreSignUnion[w_]:=Module[{A,X},
Fold[Function[{A,X},
Append[If[X===#||X===-#,Null ,#]&/@A,X]/.Null:> Sequence[]],w,w]
]


MultipleTaylorExpansion[f_,{x_,dx_,n_}]:=Module[{},Plus@@Flatten[Table[1/k!,{k,0,n}]*NestList[Function[{F},MapThread[#2 D[F,#1]&,{x,dx}]],f,n]]]


QuadraticCoefficientArrays[vars_][m_]:=(Transpose[#]+#)/2&@Last@Normal[CoefficientArrays[m,vars]]


SphereVolume[n_]=(2 \[Pi]^((n+1)/2))/Gamma[(n+1)/2]


BallVolume[n_]=(2 \[Pi]^(n/2))/Gamma[n/2]/n


HypersphericalCoordinates[n_,\[Theta]_]:=Module[{},Times@@Table[Reverse@Join[Table[1,{m,1,k-1}],{Cos[\[Theta][n-k]]},Table[Sin[\[Theta][n-k]],{m,k+1,n}]],{k,1,n-1}]]


PermutationMatrix[L_List]:=Module[{k,Id,pos},Id=IdentityMatrix[Length@L];
pos=Flatten@Table[Flatten@Position[L,k],{k,1,Length@L}];
Transpose@Map[Part[Id,#]&,pos]]


PermutationToInversionTable[L_List]:=Module[{n,u,v,temp,L2},n=Length[L];
L2=FoldList[{Part[#1,1]/.{u___,#2,v___}:>{temp=u,v},Length@{temp}}&,{L,Null},Range@Length[L]];
Drop[L2[[All,2]],1]]


Attributes[combinePairP]={Flat};


combinePairP[{pair[m_,n_],u___},{pair[mm_,nn_],v___}]:=Module[{},Which[m<=mm,Join[{pair[m,n]},combinePairP[{u},{pair[mm-m,nn],v}]],m>mm,Join[{pair[mm,nn]},combinePairP[{pair[m-mm-1,n],u},{v}]]]]


combinePairP[{},v_]:=v
combinePairP[u_,{}]:=u
combinePairP[{u__}]:={u}


InversionTableToPermutation[V_List]:=Module[{k,step},step=combinePairP@@Table[{pair[Part[V,k],k]},{k,1,Length@V}];
Map[Part[#,2]&,step]]


ContingencyTables[state_,observable_]:=Module[{permuts,disctinctstates,disctinctobservables,K},
permuts=Transpose/@Flatten[Outer[List,
Permutations[state],{observable},1]
,1];

disctinctstates = Union[state];
disctinctobservables = Union[observable];

K=Function[{p},Outer[ Count[p,{##}]&  ,disctinctstates,disctinctobservables]]/@permuts;

Union[K]
]


HessianAxis[cTable_?MatrixQ]:=Module[{r,s,Jr,Js,rList,sList,D0,DPlus,DMinus},
{r,s}= Dimensions[cTable];
Jr = LowerTriangularize[  Table[1,{r},{r}],-1];
Js = LowerTriangularize[  Table[1,{s},{s}],-1];
sList =Plus@@cTable;
rList= Plus@@Transpose[cTable];
D0=Plus@@(sList^2)-Plus@@(Flatten[cTable]^2);
DPlus = 2*Tr[Jr.cTable.Js.Transpose[cTable]];
DMinus=2*Tr[Jr.cTable.Transpose[Js].Transpose[cTable]];
{D0,DPlus,DMinus}
]


MultinomialPartitions[n_,k_]:=Module[{perms,step,step2,x,y},
perms=Permutations[Join[Table[1,{k}],Table[0,{n-1}]]];
step=Map[Split,perms]/.x:{0..}:>Sequence@@Table[0,{Length@x}];
step2=step//.{
{x___,0,0,y___}:>{x,0,{},0,y},
{x__,0}:>{x,0,{}},
{0,x__}:>{{},0,x}};
Map[Length,step2/.{0->Sequence[]},{2}]
]


MultinomialPartitionToSymmetricArray[pows_,T_]:=Module[{k = Plus@@pows},
T@@Flatten@Map[Table[Position[pows,#],{#}]&,Range[k]]
]


SymmetricArrayValueRules[T_,{n_,k_},vals_]:=Module[{powList,tens,perm,pre},powList=MultinomialPartitions[n,k];
tens=Map[MultinomialPartitionToSymmetricArray[#,T]&,powList];
pre=MapThread[{perm=Permutations[#1],Table[#2,{Length@perm}]}&,{tens,vals}];
Flatten@Map[MapThread[Rule,#]&,pre]]


SymmetricArrayPartition[{n_,k_},list_]:=Module[{T,rules},rules=SymmetricArrayValueRules[T,{n,k},list];
Array[T,Table[n,{k}]]/.rules]


SymmetricArrayElementToPolynomial[w_,x_]:=Module[{vars,max},vars=List@@w;
max=Max[vars];
Times@@Power[Array[x,max],Map[Count[vars,#]&,Range[max]]]]


SymmetricArrayToHomogeneousPolynomial[array_,x_]:=Module[{n,k},n=First[Dimensions@array];
k=Length[Dimensions@array];
Plus@@Flatten@MapThread[Times[#1*SymmetricArrayElementToPolynomial[#2,x]]&,{array,Array[x,Table[n,{k}]]},k]]


SymmetricArrayToHomogeneousPolynomial[array_,x_]:=Module[{n,k},
n=First[Dimensions@array];
k=Length[Dimensions@array];
Plus@@Flatten@MapThread[
Times[#1*SymmetricArrayElementToPolynomial[#2,x]]&,{array,Array[x,Table[n,{k}]]},k]
]


SymmetricArrayCoefficientsToHomogeneousPolynomial[list_,{n_,k_},x_]:=Plus@@MapThread[Length[Permutations@MultinomialPartitionToSymmetricArray[#2,x]]*#1*SymmetricArrayElementToPolynomial[MultinomialPartitionToSymmetricArray[#2,x],dx]&,{list,MultinomialPartitions[n,k]}]


GivensRotation[n_,{i_,j_},c_]:=Module[{},ReplacePart[IdentityMatrix[n],{{i,i}->c,{j,j}->c,{i,j}->Sqrt[1-c^2],{j,i}->-Sqrt[1-c^2]}]]


GaussianIntegral[M_]:=Module[{n=Length[M],invM=Inverse[M]},Sqrt[(2 \[Pi])^n/Det[M]]]


GaussianSecondMoment[M_,p_,q_]:=Module[{n=Length[M],invM=Inverse[M]},Sqrt[(2 \[Pi])^n/Det[M]]*Part[invM,p,q]]


TranslationOperatorT[d_]:=Module[{},ReplacePart[RotateLeft/@IdentityMatrix[d],{1,d}->Power[-1,d-1]]]


MomentumAuxFunc[n_,m_,d_]:=If[n=!=m,(Sin[\[Pi](n-m)]Cos[(\[Pi](n-m))/d]-d*Cos[\[Pi](n-m)]Sin[(\[Pi](n-m))/d])/Sin[(\[Pi](n-m))/d]^2,0];


MomentumOperatorP[{d_,1},a_]:=Module[{n,m,J},
J=(d-1)/2;
(\[Pi]*I)/(a*d^2) Table[
MomentumAuxFunc[n,m,d]
,{n,-J,J},{m,-J,J}]
]


KroneckerSum[M__]:=Module[{d1,nblocks},
nblocks =Length[{M}];
d1=Length[First@{M}];
Plus@@Map[
KroneckerProduct@@#&,MapIndexed[RotateRight[#1,Sequence@@#2]&,Map[ Prepend[Table[IdentityMatrix[d1],{nblocks-1}],#]&, {M}]]
]
]


MomentumOperatorP[{d_, n_}, a_] := Module[{},
  KroneckerSum@@Table[ MomentumOperatorP[{d, 1}, a], {n}]
  ]


ToComplexExpExpression[w_]:=Module[{\[Alpha]},
(w/.{-1->Exp[I*\[Alpha]]}//PowerExpand)/.{\[Alpha]->\[Pi]}
]


BoostOperatorB[d_]:=Module[{\[Omega],J},
J = (d-1)/2;
\[Omega] = Exp[(I*2*\[Pi])/d];
ToComplexExpExpression@DiagonalMatrix[ Table[\[Omega]^k,{k,-J,J,1}]]
]


PositionOperatorX[{d_,1},dx_]:=Module[{k,J},
J=(d-1)/2;
dx*DiagonalMatrix[ Table[k,{k,-J,J}]]
]


PositionOperatorX[{d_, n_}, a_] := Module[{},
  KroneckerSum@@Table[ PositionOperatorX[{d, 1}, a], {n}]
  ]


EhrenfestFreeHamiltonian[{d_?IntegerQ,1},a_]:=Module[{},
I*Table[   
If[k=!=l,1/(k-l) ,0]
 ,{k,1,d},{l,1,d}]*MomentumOperatorP[{d,1},a]
]


EhrenfestFreeHamiltonian[{d_,n_},a_]:=Module[{},
Plus@@Map[
KroneckerProduct@@#&,
NestList[RotateRight,
Join[{EhrenfestFreeHamiltonian[{d,1},a]},ConstantArray[IdentityMatrix[d],{n-1}]]
,n-1]
]
]


DiagonalP[{d_,1},a_]:=Module[{J,n},
J = (d-1)/2;
n = Log[2,d];
Sort@Table[ (\[Pi] j)/(a*Power[2,n-1]),{j,-J,J}]
]


DiagonalKineticEnergyPSquare[{d_,1},a_,m_]:=
Module[{J,j},
1/(2 m)*DiagonalP[{d,1},a]^2
]


DiagonalKineticEnergyPSquare[{d_, n_}, dx_, m_] := Module[{},
Plus @@ (KroneckerProduct @@ # & /@ NestList[RotateRight, Join[{DiagonalMatrix@DiagonalKineticEnergyPSquare[{d, 1}, dx, m] }, ConstantArray[IdentityMatrix[d], n - 1]], n - 1])
  ]


PropagatorStep1D[{V_,m_,dx_,dt_},\[Psi]_]:=Module[{d},
d=Length[V];
Exp[-I*V*dt/2]*SymmetricInverseFourier[Exp[-I*dt*DiagonalKineticEnergyPSquare[{d,1},dx,m]]*SymmetricFourier[Exp[-I*V*dt/2]*\[Psi]]]
]


FourierPartitionMap[stride_,XArray_,\[Omega]cos_,\[Omega]sin_,s_]:=Module[{d=Length[XArray],YArray,\[Omega]},
YArray = XArray;
\[Omega]=TrigToExp[\[Omega]cos+I*\[Omega]sin];
Do[
YArray[[i]] = Power[\[Omega],-s] YArray[[i]] +Power[\[Omega],s] YArray[[i+stride/2]] ;
,{i,1,d-stride+1,stride}];
YArray
]


SymmetricFFT[X_?VectorQ]:=Module[{d=Length[X],n,J,\[Omega],return,s,XArray,XArray2,stride,PArray,\[Omega]cos,\[Omega]sin},
n= Log[2,d];
J=(d-1)/2;
\[Omega]=Exp[I*2\[Pi]/(4  d*2)];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];
PArray = Table[ 1 ,{k,-2J,2J,2}];

Do[
stride=2;
XArray = X;
XArray2 = X;
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];

Do[
{\[Omega]cos,\[Omega]sin} = {#1^2-#2^2,2*#1*#2}&@@{\[Omega]cos,\[Omega]sin};
XArray=FourierPartitionMap[stride,XArray,\[Omega]cos,\[Omega]sin,s];
XArray2=FourierPartitionMap[stride,XArray2,\[Omega]cos,-\[Omega]sin,s];
stride*=2;
,{r,n}];

PArray[[(s+2J)/2+1]]= First@XArray;
PArray[[(-s+2J)/2+1]]= First@XArray2;

,{s,-2J,-1,2}];

PArray/Sqrt[d]
]


SymmetricInverseFFT[X_?VectorQ]:=Module[{d=Length[X],n,J,\[Omega],return,s,XArray,XArray2,stride,PArray,\[Omega]cos,\[Omega]sin},
n= Log[2,d];
J=(d-1)/2;
\[Omega]=Exp[-I*2\[Pi]/(4  d*2)];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];
PArray = Table[ 1 ,{k,-2J,2J,2}];

Do[
stride=2;
XArray = X;
XArray2 = X;
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];

Do[
{\[Omega]cos,\[Omega]sin} = {#1^2-#2^2,2*#1*#2}&@@{\[Omega]cos,\[Omega]sin};
XArray=FourierPartitionMap[stride,XArray,\[Omega]cos,\[Omega]sin,s];
XArray2=FourierPartitionMap[stride,XArray2,\[Omega]cos,-\[Omega]sin,s];
stride*=2;
,{r,n}];

PArray[[(s+2J)/2+1]]= First@XArray;
PArray[[(-s+2J)/2+1]]= First@XArray2;

,{s,-2J,-1,2}];

PArray/Sqrt[d]
]


FourierPartitionMap[stride_,d1_,XArray_,\[Omega]cos_,\[Omega]sin_,s_]:=Module[{d=Length[XArray],YArray,\[Omega]},
YArray = XArray;
\[Omega]=TrigToExp[\[Omega]cos+I*\[Omega]sin];
Do[
YArray[[i]] = Power[\[Omega],-s] YArray[[i]] + Power[\[Omega],s] YArray[[i+stride*d1/2]] ;
,{i,1,d-stride*d1+1,stride*d1}];
YArray
]


SymmetricFFTPartial10[X_?VectorQ]:=Module[{offset,d1,n1,J1,d=Length[X],n,J,\[Omega],return,s,XArray,XArray2,stride,PArray,\[Omega]cos,\[Omega]sin},
d1 = Sqrt[d];
n= Log[2,d];
n1 = Log[2,d1];

J=(d-1)/2;
J1 = (d1-1)/2;

\[Omega]=Exp[I*2\[Pi]/(4  d1*2)];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];
PArray = Table[ 1 ,{k,-2J,2J,2}];

Do[
stride=2;
XArray = RotateLeft[X,offset];
XArray2 = RotateLeft[X,offset];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];

Do[
{\[Omega]cos,\[Omega]sin} = {#1^2-#2^2,2*#1*#2}&@@{\[Omega]cos,\[Omega]sin};
XArray=FourierPartitionMap[stride,d1,XArray   ,\[Omega]cos,\[Omega]sin,s];
XArray2=FourierPartitionMap[stride,d1,XArray2,\[Omega]cos,-\[Omega]sin,s];
stride*=2;
,{r,n1}];

PArray[[d1*(s+2J1)/2+offset+1]]= First@XArray;
PArray[[d1*(-s+2J1)/2+offset+1]]= First@XArray2;


,{s,-2J1,-1,2},{offset,0,d1-1}];

PArray/Sqrt[d1]
]


SymmetricInverseFFTPartial10[X_?VectorQ]:=Module[{offset,d1,n1,J1,d=Length[X],n,J,\[Omega],return,s,XArray,XArray2,stride,PArray,\[Omega]cos,\[Omega]sin},
d1 = Sqrt[d];
n= Log[2,d];
n1 = Log[2,d1];

J=(d-1)/2;
J1 = (d1-1)/2;

\[Omega]=Exp[-I*2\[Pi]/(4  d1*2)];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];
PArray = Table[ 1 ,{k,-2J,2J,2}];

Do[
stride=2;
XArray = RotateLeft[X,offset];
XArray2 = RotateLeft[X,offset];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];

Do[
{\[Omega]cos,\[Omega]sin} = {#1^2-#2^2,2*#1*#2}&@@{\[Omega]cos,\[Omega]sin};
XArray=FourierPartitionMap[stride,d1,XArray   ,\[Omega]cos,\[Omega]sin,s];
XArray2=FourierPartitionMap[stride,d1,XArray2,\[Omega]cos,-\[Omega]sin,s];
stride*=2;
,{r,n1}];

PArray[[d1*(s+2J1)/2+offset+1]]= First@XArray;
PArray[[d1*(-s+2J1)/2+offset+1]]= First@XArray2;


,{s,-2J1,-1,2},{offset,0,d1-1}];

PArray/Sqrt[d1]
]


SymmetricFFTPartial01[X_?VectorQ]:=Module[{d1,n1,J1,d=Length[X],n,J,\[Omega],return,s,XArray,XArray2,stride,PArray,\[Omega]cos,\[Omega]sin},
d1=Sqrt[d];
n= Log[2,d];
n1=Log[2,d1];

J=(d-1)/2;
J1=(d1-1)/2;

\[Omega]=Exp[I*2\[Pi]/(4  d1*2)];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];
PArray = Table[ 1 ,{k,-2J,2J,2}];

Do[
stride=2;
XArray = RotateLeft[X,d1*offset];
XArray2 = RotateLeft[X,d1*offset+d/2];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];

Do[
{\[Omega]cos,\[Omega]sin} = {#1^2-#2^2,2*#1*#2}&@@{\[Omega]cos,\[Omega]sin};
XArray=FourierPartitionMap[stride,XArray,\[Omega]cos,\[Omega]sin,s];
XArray2=FourierPartitionMap[stride,XArray2,\[Omega]cos,-\[Omega]sin,s];
stride*=2;
,{r,n1}];

PArray[[offset*d1+(s+2J1)/2+1]]= First@XArray;
PArray[[offset*d1+d/2+(-s+2J1)/2+1]]= First@XArray2;

,{s,-2J1,2J1,2},{offset,0,d1/2-1}];

PArray/Sqrt[d1]
]


SymmetricInverseFFTPartial01[X_?VectorQ]:=Module[{d1,n1,J1,d=Length[X],n,J,\[Omega],return,s,XArray,XArray2,stride,PArray,\[Omega]cos,\[Omega]sin},
d1=Sqrt[d];
n= Log[2,d];
n1=Log[2,d1];

J=(d-1)/2;
J1=(d1-1)/2;

\[Omega]=Exp[-I*2\[Pi]/(4  d1*2)];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];
PArray = Table[ 1 ,{k,-2J,2J,2}];

Do[
stride=2;
XArray = RotateLeft[X,d1*offset];
XArray2 = RotateLeft[X,d1*offset+d/2];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];

Do[
{\[Omega]cos,\[Omega]sin} = {#1^2-#2^2,2*#1*#2}&@@{\[Omega]cos,\[Omega]sin};
XArray=FourierPartitionMap[stride,XArray,\[Omega]cos,\[Omega]sin,s];
XArray2=FourierPartitionMap[stride,XArray2,\[Omega]cos,-\[Omega]sin,s];
stride*=2;
,{r,n1}];

PArray[[offset*d1+(s+2J1)/2+1]]= First@XArray;
PArray[[offset*d1+d/2+(-s+2J1)/2+1]]= First@XArray2;

,{s,-2J1,2J1,2},{offset,0,d1/2-1}];

PArray/Sqrt[d1]
]


FourierPartitionMap100[stride_,d1_,XArray_,\[Omega]cos_,\[Omega]sin_,s_]:=
Module[{d=Length[XArray],YArray,\[Omega]},
YArray = XArray;
\[Omega]=TrigToExp[\[Omega]cos+I*\[Omega]sin];
Do[
YArray[[i]] = Power[\[Omega],-s] YArray[[i]] + Power[\[Omega],s] YArray[[i+stride*d1*d1/2]] ;
,{i,1,d-stride*d1*d1+1,stride*d1*d1}];
YArray
]


SymmetricFFTPartial100[X_?VectorQ]:=Module[{offset,d1,n1,n2,J1,d=Length[X],n,J,\[Omega],return,s,XArray,XArray2,stride,PArray,\[Omega]cos,\[Omega]sin},
d1 = Power[d,1/3];
n= Log[2,d];
n1 = n/3;
n2 = 2*n1;

J=(d-1)/2;
J1 = (d1-1)/2;

\[Omega]=Exp[I*2\[Pi]/(4  d1*2)];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];
PArray = Table[ 1 ,{k,-2J,2J,2}];

Do[
stride=2;
XArray = RotateLeft[X,offset];
XArray2 = RotateLeft[X,offset];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];

Do[
{\[Omega]cos,\[Omega]sin} = {#1^2-#2^2,2*#1*#2}&@@{\[Omega]cos,\[Omega]sin};
XArray  =FourierPartitionMap100[stride,d1,XArray   ,\[Omega]cos,\[Omega]sin,s];
XArray2=FourierPartitionMap100[stride,d1,XArray2,\[Omega]cos,-\[Omega]sin,s];
stride*=2;
,{r,n1}];

PArray[[d1*d1*(s+2J1)/2+offset+1]]= First@XArray;
PArray[[d1*d1*(-s+2J1)/2+offset+1]]= First@XArray2;


,{s,-2J1,-1,2},{offset,0,d1*d1-1}];

PArray/Sqrt[d1]
]


SymmetricInverseFFTPartial100[X_?VectorQ]:=Module[{offset,d1,n1,n2,J1,d=Length[X],n,J,\[Omega],return,s,XArray,XArray2,stride,PArray,\[Omega]cos,\[Omega]sin},
d1 = Power[d,1/3];
n= Log[2,d];
n1 = n/3;
n2 = 2*n1;

J=(d-1)/2;
J1 = (d1-1)/2;

\[Omega]=Exp[-I*2\[Pi]/(4  d1*2)];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];
PArray = Table[ 1 ,{k,-2J,2J,2}];

Do[
stride=2;
XArray = RotateLeft[X,offset];
XArray2 = RotateLeft[X,offset];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];

Do[
{\[Omega]cos,\[Omega]sin} = {#1^2-#2^2,2*#1*#2}&@@{\[Omega]cos,\[Omega]sin};
XArray  =FourierPartitionMap100[stride,d1,XArray   ,\[Omega]cos,\[Omega]sin,s];
XArray2=FourierPartitionMap100[stride,d1,XArray2,\[Omega]cos,-\[Omega]sin,s];
stride*=2;
,{r,n1}];

PArray[[d1*d1*(s+2J1)/2+offset+1]]= First@XArray;
PArray[[d1*d1*(-s+2J1)/2+offset+1]]= First@XArray2;


,{s,-2J1,-1,2},{offset,0,d1*d1-1}];

PArray/Sqrt[d1]
]


SymmetricFFTPartial001[X_?VectorQ]:=Module[{d1,n1,J1,d=Length[X],n,J,\[Omega],return,s,XArray,XArray2,stride,PArray,\[Omega]cos,\[Omega]sin},
d1=Power[d,1/3];
n= Log[2,d];
n1=n/3;

J=(d-1)/2;
J1=(d1-1)/2;

\[Omega]=Exp[I*2\[Pi]/(4  d1*2)];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];
PArray = Table[ 1 ,{k,-2J,2J,2}];

Do[
stride=2;
XArray = RotateLeft[X,d1*offset];
XArray2 = RotateLeft[X,d1*offset+d/2];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];

Do[
{\[Omega]cos,\[Omega]sin} = {#1^2-#2^2,2*#1*#2}&@@{\[Omega]cos,\[Omega]sin};
XArray=FourierPartitionMap[stride,XArray,\[Omega]cos,\[Omega]sin,s];
XArray2=FourierPartitionMap[stride,XArray2,\[Omega]cos,-\[Omega]sin,s];
stride*=2;
,{r,n1}];

PArray[[offset*d1+(s+2J1)/2+1]]= First@XArray;
PArray[[offset*d1+d/2+(-s+2J1)/2+1]]= First@XArray2;

,{s,-2J1,2J1,2},{offset,0,d1*d1/2-1}];

PArray/Sqrt[d1]
]


SymmetricFFTPartial010[X_?VectorQ]:=Module[{offset,d1,d2,n1,n2,J1,J2,d=Length[X],n,J,\[Omega],return,s,XArray,XArray2,stride,PArray,\[Omega]cos,\[Omega]sin},
d1 = Power[d,1/3];
n= Log[2,d];
n1 = n/3;
n2 = 2*n1;
d2 = Power[2,n2];

J=(d-1)/2;
J1 = (d1-1)/2;
J2 = (d2-1)/2;

\[Omega]=Exp[I*2\[Pi]/(4  d1*2)];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];
PArray = Table[ 1 ,{k,-2J,2J,2}];

Do[
stride=2;
XArray = RotateLeft[X,offset+OFFSET*d1*d1];
XArray2 = RotateLeft[X,offset+OFFSET*d1*d1];
\[Omega]cos = Re[\[Omega]];
\[Omega]sin = Im[\[Omega]];

Do[
{\[Omega]cos,\[Omega]sin} = {#1^2-#2^2,2*#1*#2}&@@{\[Omega]cos,\[Omega]sin};
XArray=FourierPartitionMap[stride,d1,XArray   ,\[Omega]cos,\[Omega]sin,s];
XArray2=FourierPartitionMap[stride,d1,XArray2,\[Omega]cos,-\[Omega]sin,s];
stride*=2;
,{r,n1}];

PArray[[d1*(s+2J1)/2+offset+OFFSET*d1*d1+1]]= First@XArray;
PArray[[d1*(-s+2J1)/2+offset+OFFSET*d1*d1+1]]= First@XArray2;


,{s,-2J1,-1,2},{offset,0,d1-1},{OFFSET,0,d1-1}];

PArray/Sqrt[d1]
]


SymmetricFourierMatrix[{n_,1}]:=Module[{J,j,\[Omega],d = 2^n},
 J=(d-1)/2;
\[Omega] = Exp[I*2*\[Pi]/d];
1/Sqrt[2^n] Table[  \[Omega]^(j*k),{j,-J,J},{k,-J,J}]
]


SymmetricInverseFourierMatrix[{n_,1}]:=Module[{J,j,\[Omega],d = 2^n},
J= J=(d-1)/2;
\[Omega] = Exp[-I*2*\[Pi]/d];
1/Sqrt[2^n] Table[  \[Omega]^(j*k),{j,-J,J},{k,-J,J}]
]


SymmetricFourierMatrix[{n_,2}]:=Module[{J,j,\[Omega],d = 2^n},
 J=(d-1)/2;
\[Omega] = Exp[I*2*\[Pi]/d];
1/Sqrt[2^(2n)] ArrayFlatten@Table[
Table[ Power[\[Omega], x*px+y*py] ,{px,-J,J},{x,-J,J}],
{py,-J,J},{y,-J,J}]
]


SymmetricInverseFourierMatrix[{n_,2}]:=Module[{J,j,\[Omega],d = 2^n},
 J=(d-1)/2;
\[Omega] = Exp[-I*2*\[Pi]/d];
1/Sqrt[2^(2n)] ArrayFlatten@Table[
Table[ Power[\[Omega], x*px+y*py] ,{px,-J,J},{x,-J,J}],
{py,-J,J},{y,-J,J}]
]


StandardFourierMatrix[n_]:=Module[{J,j,\[Omega],d = 2^n},
\[Omega] = Exp[I*2*\[Pi]/d];
1/Sqrt[2^n] Table[  \[Omega]^(j*k),{j,0,d-1},{k,0,d-1}]
]


FourierPhaseCorrection[x_]:=Module[{J,\[Omega],d},
d = Length[x];
J = (d-1)/2;
\[Omega] = Exp[I*2.*\[Pi]/d];
Table[Power[\[Omega],-J*y]*Part[x,y+1],{y,0,2J}]
]


SymmetricFourier[w_?VectorQ]:=Module[{d=Length[w],J,\[Omega]},
J=(d-1)/2;
\[Omega] = Exp[I*2.*\[Pi]/d];
Power[\[Omega],J^2]FourierPhaseCorrection@Fourier[FourierPhaseCorrection@w]
]


InverseFourierPhaseCorrection[x_]:=Module[{J,\[Omega],d},d=Length[x];
J=(d-1)/2;
\[Omega]=Exp[-I*2*\[Pi]/d];
Table[Power[\[Omega],-J*y]*Part[x,y+1],{y,0,2 J}]]


SymmetricInverseFourier[w_?VectorQ]:=Module[{d=Length[w],J,\[Omega]},
J=(d-1)/2;
\[Omega] = Exp[-I*2.*\[Pi]/d];
Power[\[Omega],J^2]InverseFourierPhaseCorrection@InverseFourier[InverseFourierPhaseCorrection@w]
]


FastSymmetricFourier[w_?VectorQ]:=Module[{d=Length[w]},RotateLeft[#,d/2]&@Fourier[RotateLeft[#,d/2]&@w]]


FastSymmetricInverseFourier[w_?VectorQ]:=Module[{d=Length[w]},RotateLeft[#,d/2]&@InverseFourier[RotateLeft[#,d/2]&@w]]


FourierPhaseCorrection2D[v_?MatrixQ]:=Module[{J,\[Omega],d},
d = Length[v];
J = (d-1)/2;
\[Omega] = Exp[I*2.*\[Pi]/d];
Table[Power[\[Omega],-J*(x+y)]*Part[v,x+1,y+1],{y,0,2J},{x,0,2J}]
]


SymmetricFourier2D[w_?MatrixQ]:=Module[{d=Length[w],d1,J,\[Omega]},
J=(d-1)/2;
\[Omega] = Exp[I*2.*\[Pi]/d];
Power[\[Omega],2*J^2]*FourierPhaseCorrection2D@Fourier[FourierPhaseCorrection2D@w]
]


SymmetricFourier2D[w_?VectorQ]:=Module[{d = Length[w],d1},
d1 = Sqrt[d];
Flatten@SymmetricFourier2D@Partition[w,d1]
]


InverseFourierPhaseCorrection2D[v_?MatrixQ]:=Module[{J,\[Omega],d},
d = Length[v];
J = (d-1)/2;
\[Omega] = Exp[-I*2.*\[Pi]/d];
Table[Power[\[Omega],-J*(x+y)]*Part[v,x+1,y+1],{y,0,2J},{x,0,2J}]
]


SymmetricInverseFourier2D[w_?MatrixQ]:=Module[{d=Length[w],J,\[Omega]},
J=(d-1)/2;
\[Omega] = Exp[-I*2.*\[Pi]/d];
Power[\[Omega],2*J^2]*InverseFourierPhaseCorrection2D@InverseFourier[InverseFourierPhaseCorrection2D@w]
]


SymmetricInverseFourier2D[w_?VectorQ]:=Module[{d = Length[w],d1},
d1 = Sqrt[d];
Flatten@SymmetricInverseFourier2D@Partition[w,d1]
]


ToSymmetricIndex[i_,d_]:=Module[{J=(d-1)/2},i-J-1]


ToPositiveIntegerIndex[i_,d_]:=Module[{J=(d-1)/2}, Mod[i+J ,d]+1]


LeftSymmetricInverseFourier2D[w_]:=Module[{d,d1,J,J1,\[Omega]1,j,q,j1,j2},
d= Length[w];
d1=Sqrt[d];
J=(d-1)/2;
J1=(d1-1)/2;
\[Omega]1 = Exp[-I*2.*\[Pi]/d1];
Table[
j2 =ToSymmetricIndex[Floor[ k/d1]+1,d1];
Sum[ 
j1 = ToSymmetricIndex[Mod[ToPositiveIntegerIndex[j,d]-1,d]/d1+1,d1];
Power[\[Omega]1,j1*j2]*Part[w,ToPositiveIntegerIndex[j,d]+Mod[k,d1]] ,{j,-J,J,d1}]
,{k,0,d-1}]/Sqrt[d1]
]


LeftSymmetricFourier2D[w_]:=Module[{d,d1,J,J1,\[Omega]1,j,q,j1,j2},
d= Length[w];
d1=Sqrt[d];
J=(d-1)/2;
J1=(d1-1)/2;
\[Omega]1 = Exp[I*2.*\[Pi]/d1];
Table[
j2 =ToSymmetricIndex[Floor[ k/d1]+1,d1];
Sum[ 
j1 = ToSymmetricIndex[Mod[ToPositiveIntegerIndex[j,d]-1,d]/d1+1,d1];
Power[\[Omega]1,j1*j2]*Part[w,ToPositiveIntegerIndex[j,d]+Mod[k,d1]] ,{j,-J,J,d1}]
,{k,0,d-1}]/Sqrt[d1]
]


FourierColumns[M_]:= Fourier/@M


FourierRows[M_]:= Transpose[Fourier/@Transpose[M]]


ShiftFrequencyRows[DIM_,M_]:=RotateRight[M,DIM/2]


ShiftFrequencyColumns[DIM_,M_]:=RotateRight[#,DIM/2]&/@M


InverseFourierColumns[M_]:= InverseFourier/@M


InverseFourierRows[M_]:= Transpose[InverseFourier/@Transpose[M]]


Norm2D[x_]:=Abs[Plus@@(Plus@@(x*Conjugate[x]))];
Normalize2D[x_]:=x/Sqrt[   Norm2D[x] ]


SetUnifiedPropagationFrame1D[{QuantumK_,QuantumV_,Initial\[Psi]_},{discretizationNumber_,nTimeFrames_},{\[CapitalDelta]x_,\[CapitalDelta]p_,T_}]:=Module[{dp,dx,\[CapitalDelta]\[Lambda],\[CapitalDelta]\[Theta],d\[Lambda],d\[Theta],unifiedGridV,unifiedGridK,quantumGridV,quantumGridK,dt,quantumExpK,quantumExpV,quantumExpKShiftColumns,quantumExpVShiftRows,\[Psi]0},
dp = \[CapitalDelta]p/(discretizationNumber-1.);
dx = \[CapitalDelta]x/(discretizationNumber-1.);
\[CapitalDelta]\[Lambda]= (2\[Pi])/dx;
\[CapitalDelta]\[Theta]= (2\[Pi])/dp;
d\[Lambda]=\[CapitalDelta]\[Lambda]/(discretizationNumber-1);
d\[Theta]=\[CapitalDelta]\[Theta]/(discretizationNumber-1);
dt = T/nTimeFrames;

quantumGridK= Table[
QuantumK[\[Lambda],p],{p,-\[CapitalDelta]p/2,\[CapitalDelta]p/2,dp},{\[Lambda],-\[CapitalDelta]\[Lambda]/2,\[CapitalDelta]\[Lambda]/2,d\[Lambda]}];

quantumExpK = Exp[-I*quantumGridK*dt];

quantumExpKShiftColumns = ShiftFrequencyColumns[discretizationNumber,quantumExpK];

(*..........................*)

quantumGridV= Table[ 
QuantumV[x,\[Theta]],{\[Theta],-\[CapitalDelta]\[Theta]/2,\[CapitalDelta]\[Theta]/2,d\[Theta]},{x,-\[CapitalDelta]x/2,\[CapitalDelta]x/2,dx}];

quantumExpV = Exp[-I*quantumGridV*dt];

quantumExpVShiftRows = ShiftFrequencyRows[discretizationNumber,quantumExpV];

(*..............................*)

\[Psi]0= Normalize2D@Table[Initial\[Psi][x,p],{p,-\[CapitalDelta]p/2,\[CapitalDelta]p/2,dp},{x,-\[CapitalDelta]x/2,\[CapitalDelta]x/2,dx}];

{quantumExpKShiftColumns,quantumExpVShiftRows,\[Psi]0}
]


StepPropagationXP[quantumExpKShiftColumns_,quantumExpVShiftRows_][\[Psi]_]:= FourierColumns[
quantumExpKShiftColumns*InverseFourierColumns[
FourierRows[quantumExpVShiftRows*InverseFourierRows[\[Psi]]]
]
]


SymplecticDT[{q_,p_},dt_,dTdp_,c_]:=Module[{},
{q+c*dt*dTdp[q,p],p}
]


SymplecticDV[{q_,p_},dt_,dVdq_,d_]:=Module[{},
{q,p-d*dt*dVdq[q,p]}
]


SymplecticPropagatorStep2[{q_,p_},dt_,dTdp_,dVdq_]:=Module[{step1},
step1=SymplecticDT[ #,dt,dTdp,1.0]&@SymplecticDV[{q,p},dt,dVdq,0.5];
SymplecticDV[step1,dt,dVdq,0.5]
]


SymplecticPropagator2[X_,dTdp_,dVdq_,t0_,T_,DIMtime_]:=Module[{dt},
dt = T/DIMtime;
NestList[
SymplecticPropagatorStep2[#,dt,dTdp,dVdq]&
,X,DIMtime]
]


WignerFunctionFFT[g_]:=Module[{n,G,shift,k,ones,arg,left,right,s},n=Length[g];
G=List@InverseFourier[g];
shift=List/@(Range[0,n-1]-n/2);
k=List@RotateRight[Reverse[-Range[1,n]],n/2];
ones=List/@ConstantArray[1,n];
arg=Transpose[2. \[Pi] I/n RotateRight[#,n/2]&/@Transpose[shift.k]];
left=Fourier/@((ones.G)*Exp[arg/2]);
right=Fourier/@((ones.G)*Exp[-arg/2]);
Transpose[InverseFourier/@Transpose[left*Conjugate[right]]]/Sqrt[n]]


SymmetricWignerFunction[g_]:=Module[
{F,iF,n,d,G,\[Phi],\[CurlyPhi],J,ones,arg,left,right,s},
n = Length[g];
d=Log[2,n];
J = (n-1)/2;
s = Sqrt[n];

F =  N[SymmetricInverseFourierMatrix[{d,1}]];
iF= ConjugateTranspose@F;

G = List/@(F.g);
(*G = List/@g;*)

\[Phi] = {Table[k,{k,-J,J}]};
\[CurlyPhi] = Transpose@{Table[k/2,{k,J,-J,-1}]};

ones = {ConstantArray[1,n]};
arg = 2\[Pi]/n \[CurlyPhi].\[Phi] ;

right=iF.( (G.ones)*Exp[-I*arg]);
left = iF.( (G.ones)*Exp[+I*arg]);
Re[F.#&/@(Conjugate[left]*right)]/s
]


(* ::Input:: *)
End[]


(* ::Input:: *)
EndPackage[]
